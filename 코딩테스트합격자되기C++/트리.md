# 트리

## 트리의 개념
> 노드와 간선으로 이루어지니 계층적 자료구조 (부모-자식 관계 존재)


- 순환을 허용하지 않음
- 코딩 테스트에서는 이진트리(자식 노드가 최대 2개인 트리)만 알면 됨

## 이진 트리 표현 하기(배열)
- 루트 노드 인덱스는 1
- 왼쪽 자식 노드는 부모노드 인덱스 * 2
- 오른쪽 자식 노드는 부모노드 인덱스 * 2 + 1
- 인덱스 공식만 활용하므로 구현난이도가 낮음
- 단점으로는 빈공간이 많음 (메모리 낭비)


## 이진 트리 표현 하기(인접 리스트)
- 각 리스트의 인덱스는 부모 노드
- 자식 노드는 부모 노드에 해당되는 인덱스에 추가
- 배열보다 공간 효율이 좋음
- 자식 노드를 찾는데 오래 걸릴 수 있음 (순차탐색 필요함, 이진 트리는 자식이 2개이므로 큰 단점은 아님)

## 이진 트리의 순회
- 트리의 노드를 모두 방문하는 방법
- 현재 노드를 언제 방문하는지에 따라 전위순회, 중위순회, 후위순회로 분류

### 전위 순회
- 부모 노드 -> 왼쪽 자식 노드 -> 오른쪽 자식 노드
- 루트 노드 부터 시작
- 사용 예시 : 트리 복사

### 중위 순회
- 왼쪽 자식 노드 -> 부모 노드 -> 오른쪽 자식 노드
- 사용 예시 : 정렬된 상태로 순회

### 후위 순회
- 왼쪽 자식 노드 -> 오른쪽 자식 노드 -> 부모 노드
- 사용 예시 : 폴더 삭제 하기

## 이진 탐색 트리 특성
- 최대 탐색 횟수는 트리의 높이와 같다
- 최악의 경우 ```O(N)```이지만, 균형 유지시 ```O(logN)```이다
- 삽입과 동시에 정렬을 한다
- map, set의 내부는 균형이진탐색트리로 되어있음


# 문제풀이

## 예상 대진표
- https://school.programmers.co.kr/learn/courses/30/lessons/12985


### 시간 복잡도 분석
- N은 2^1 이상 2^20 이하
  - 사실상 최대 20번만 비교하면 되므로 ```O(2^N)``` 
  - 대부분의 알고리즘 사용 가능

### 사용할 알고리즘 분석
- 토너먼트 대진표이므로 구조는 이진트리와 유사
- 다만 트리를 구현하지 않아도 문제 풀이는 가능

### 설계
- 라운드가 진행되면 수가 반으로 줄어듬
- 홀수 번호는 +1을 해서 2로 나누면 다음 라운드 번호가 됨
- 짝수 번호는 그대로 2로 나누면 다음 라운드 번호가 됨
- 둘이 만나는 순간이 정답이므로, 둘이 만나는 순간까지 반복문을 돌리면 됨

```java
class Solution
{
    public int solution(int n, int a, int b)
    {
        int answer = 0;

        for (int i = 1; i <= n; i++) {
            a = a % 2 != 0 ? (a + 1) / 2 : a / 2;
            b = b % 2 != 0 ? (b + 1) / 2 : b / 2;
            if (a == b) {
                answer = i;
                break;
            }
        }

        return answer;
    }
}
```