# 해시




# 문제풀이

## 오픈채팅방
- https://school.programmers.co.kr/learn/courses/30/lessons/42888

### 시간 복잡도 분석
- 문자열이 담긴 배열의 길이는 1 이상 100,000 이하
  - ```O(NlogN)``` 까지 사용이 가능
  - 이중 for문 사용 불가

### 사용할 알고리즘 분석
- ```유저 아이디```와 ```닉네임```을 짝지어서 저장할 필요가 있다.
  - HashMap을 사용해서 저장하는게 적합
- 중간에 닉네임이 변경되면 이전 결과값이 수정되어야함
  - 결과값을 ArrayList에 담아서 순서 유지 및 수정 가능하도록 함

### 설계
- ```유저 아이디```를 key로, ```닉네임```을 value로 넣어서 저장
  - ```닉네임```이 수정되면 바로바로 반영
- 닉네임이 중간에 계속 바뀌기 때문에 결과 String에는 우선 ```유저 아이디```로 저장
  - "uid1234 들어왔습니다.", "uid1234 나갔습니다."
- 모든 순서가 끝나면 변환작업
  - "Prodo님이 들어왔습니다.", "Prodo님이 나갔습니다."


```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
class Solution {
    public String[] solution(String[] record) {
        List<String> resultOrder = new ArrayList<>();
        Map<String, String> nickNameMap = new HashMap<>();
        for (String s : record) {
            recordDto recordDto = recordParser(s);

            if (!nickNameMap.containsKey(recordDto.uid)) {
                nickNameMap.put(recordDto.uid, recordDto.nickname);
            }

            if (recordDto.action.equals("Enter")) {
                resultOrder.add(recordDto.uid + " 들어왔습니다.");
                nickNameMap.put(recordDto.uid, recordDto.nickname);
            } else if (recordDto.action.equals("Leave")) {
                resultOrder.add(recordDto.uid + " 나갔습니다.");
            } else {
                nickNameMap.put(recordDto.uid, recordDto.nickname);
            }
        }

        String[] answer = new String[resultOrder.size()];
        for (int i=0; i<resultOrder.size(); i++) {
            String[] split = resultOrder.get(i).split(" ");
            answer[i] = nickNameMap.get(split[0]) + "님이 " + split[1];
        }
        return answer;
    }
    
    
    public recordDto recordParser(String record) {
    String[] split = record.split(" ");

        if (split.length == 3) {
            return new recordDto(split[0], split[1], split[2]);
        } else {
            return new recordDto(split[0], split[1], null);
        }
    }

    public class recordDto {
        String action;
        String uid;
        String nickname;

        public recordDto(String action, String uid, String nickname) {
            this.action = action;
            this.uid = uid;
            this.nickname = nickname;
        }
    }
}
```

## 메뉴 리뉴얼

- https://school.programmers.co.kr/learn/courses/30/lessons/72411

### 시간 복잡도 분석
- orders 배열의 크기는 2 이상 20 이하
- orders 빼열의 각 원소는 크기가 2 이상 10 이하의 문자열
- course 배열의 크기는 1 이상 10 이하
  - ```O(2^N)``` 까지 사용이 가능
  - 사실상 거의 모든 알고리즘 사용이 가능

### 사용할 알고리즘 분석
- 메뉴로 코스를 만드려면 조합(Combination)을 사용해서 모든 경우의 수를 구해야함
  - 코스 사이즈 별로 조합을 구하고 Counting을 해야하므로 Map을 사용하는게 적합
- 조합을 구하는 방법
  - 재귀를 사용해서 구현
- 많이 주문된 메뉴를 찾아야하므로 Count 오름차순 정렬이 필요

### 설계
- course 배열을 for문을 돌려서 코스 사이즈별로 작업 진행
- course for문 안에서 orders 배열을 for문을 돌려서 사이즈별 조합을 구하고 Map에 저장
- Map에 저장된 값들을 정렬해서 2번 이상 주문 & 가장 많이 주문된 메뉴를 찾아서 List에 저장
- List를 ABC순 오름차순 정렬해서 결과값에 저장


```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
class Solution {
    public String[] solution(String[] orders, int[] course) {

        List<String> answerArray = new ArrayList<>();

        for (int count : course) {
            Map<String, Integer> orderMap = new HashMap<>();
            for (String order : orders) {
                char[] charArray = order.toCharArray();
                Arrays.sort(charArray);
                boolean[] visited = new boolean[charArray.length];

                orderCombination(charArray, visited, 0, count, orderMap);
            }

            int max = 0;
            for (String s : orderMap.keySet()) {
                max = Math.max(max, orderMap.get(s));
            }
            if (max >= 2) {
                for (Map.Entry<String, Integer> entry : orderMap.entrySet()) {
                    if (entry.getValue() == max) answerArray.add(entry.getKey());
                }
            }
        }

        Collections.sort(answerArray);

        String[] answer = answerArray.toArray(new String[0]);


        return answer;
    }

    void orderCombination(char[] arr, boolean[] visited, int depth, int r, Map<String, Integer> orderMap) {
        if(r == 0) {
            print(arr, visited, orderMap);
            return;
        }
        if(depth == arr.length) {
            return;
        } else {
            visited[depth] = true;
            orderCombination(arr, visited, depth + 1, r - 1, orderMap);

            visited[depth] = false;
            orderCombination(arr, visited, depth + 1, r, orderMap);
        }
    }

    void print(char[] arr, boolean[] visited, Map<String, Integer> orderMap) {
        StringBuilder stringBuilder = new StringBuilder();
        for(int i = 0; i < arr.length; i++) {
            if(visited[i])
                stringBuilder.append(arr[i]);
        }
        String order = stringBuilder.toString();
        if (orderMap.containsKey(order)) {
            orderMap.put(order, orderMap.get(order)+1);
        } else {
            orderMap.put(order, 1);
        }
    }
}
```