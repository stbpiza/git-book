# 그래프

## 그래프의 개념
> - 노드와 간선을 이용한 비선형 자료구조


- 목적에 따라 간선의 가중치나 방향이 있을 수 있음

## 그래프의 종류

- 가중치가 있는 그래프
- 가중치가 없는 그래프
- 방향성 그래프
  - 간선에 방향이 있는 그래프
  - 서로를 가리키는 방향으로 간선이 있을 수 있음
- 순환(```Cycle```)이 있는 그래프
  - 한 노드에서 시작해서 다시 돌아와서 끝나는 경로가 있는 그래프
- 순환이 없는 그래프

## 그래프의 구현

### 인접 행렬
- 행과 열의 인덱스로 노드의 값을 나타내고, 배열의 값은 간선의 가중치가 됨
- 노드 대비 간선이 적을 경우 메모리 공간효율이 좋지 않음
  - 노드가 100개이고 간선이 1개인 경우에도 100x100의 행렬이 필요
- 특정 노드 사이 간선존재 여부를 한 번에 알 수 있음

### 인접 리스트
- 특정 시작 노드를 기준으로 연결된 노드들을 리스트로 연결하는 방식
- 실제 그래프의 노드 개수만큼만 추가하므로 메모리 낭비 없음
- 특정 노드에 모든 노드가 연결된 경우, 탐색시 ```O(N)```의 시간복잡도를 가짐(드문 케이스)


- 인접 리스트 표현 방식
  1. 노드 개수만큼 배열을 준비한다
  2. 각 배열의 인덱스는 시작 노드를 나타냄, 해당 인덱스에 연결된 노드 추가
  3. (V, W) : 시작 노드에서 정점 V로 가고, 가중치가 W인 간선이 존재함

### 인접 행렬 VS 인접 리스트

- 인접 행렬
  - 공간 복잡도 
    - ```O(V^2)```
  - 특정 노드 사이 간선 존재 여부 
    - ```O(1)```
  - 그래프의 모든 간선을 찾는 경우 
    - ```O(V^2)```
- 인접 리스트
  - 공간 복잡도 
    - ```O(V+E)```
  - 특정 노드 사이 간선 존재 여부 
    - ```O(E)```, 대부분은 ```O(E/V)```
  - 그래프의 모든 간선을 찾는 경우 
    - ```O(V+E)```


- 노드의 개수가 많은 경우에는 인접 리스트 사용이 유리 
- 특정 정점의 간선을 찾는 경우가 많을때만 인접 행렬 사용 고려
- 대부분의 경우 인접 리스트 사용이 유리

## 그래프 탐색

### 깊이 우선 탐색(DFS)
- 더 이상 탐색할 노드가 없을 때까지 일단 간다.
- 더 이상 탐색할 노드가 없으면 최근에 방문했던 노드로 돌아가고(```퇴각```, ```백트래킹```), 가지 않은 노드 방문


- 구현해야 할 동작
  1. 계속해서 깊이 탐색할 수 있어야 함
  2. 더 이상 깊은 곳이 없는 경우, 가장 최근에 방문했던 노드로 ```퇴각```해야함
  3. 이미 방문한 노드는 중복해서 방문하지 않아야 함
- 구현 방법
  - LIFO 구조인 스택을 활용
  - 함수의 call stack도 스택과 같이 동작하므로 재귀함수를 사용하여 구현 가능
  - visited 배열을 활용해서 방문 여부를 확인 후 방문

### 너비 우선 탐색(BFS)
- 현재 위치에서 가장 가까운 노드부터 방문하고 다음 노드로 넘어감
- 모든 노드를 방문할 때 까지 반복


- 구현해야 할 동작
  1. 루트노드부터 시작해서, 가장 가까운 노드들부터 방문할 수 있어야 함
    - 루트노드 방문 -> 1개 간선으로 갈 수 있는 노드 방문 -> 2개 간선으로 갈 수 있는 노드 방문 -> 반복

- 구현 방법
  - FIFO 구조인 큐를 활용
    1. 시작 노드 푸시
    2. 팝 후에 방문처리 이후, 현재 노드에서 연결된 노드중 방문하지 않은 노드 모두 푸시
    3. 모든 노드를 방문할 때까지 2번 반복


### 깊이 우선 탐색 VS 너비 우선 탐색
- 백트래킹은 깊이 우선 탐색에만 존재
  - 스도쿠 문제, 1~5를 사용해서 합이 10이 되는 모든 경우
- 너비 우선 탬색으로 찾은 해만 최적해를 보장
  - 시작점에서 끝지점 까지 가는 최단거리
- 너비 우선 탐색은 모든 다음 노드를 큐에 푸시하므로 깊이 우선 탐색보다 메모리 사용량이 높다
- 둘 다 사용 가능한 경우도 존재, 애매한 경우에는 깊이 우선 탐색 먼저 시도


### 최단 경로 알고리즘 찾아보기
- 너비 우선 탐색을 활용하여 최단 경로를 찾을 수 있음
- 간선의 가중치가 모두 양수라면, 해당 단계까지의 최소 비용이 갱신될 여지가 없음
  - 특정 노드까지의 최단 경로를 찾을 수 있음(```후보노드```)
  - 후보노드 까지는 저장된 비용 사용, 후보노드에서 다음 노드까지의 비용만 새로 계산

### 다익스트라 알고리즘
1. 시작 노드 A의 최소 비용을 0으로 하고, 직전 노드를 A로 변경함
2. A를 후보노드로 정함(visited에 속하지 않은 노드 중 최소비용)
3. 후보노드에서 갈 수 있는 노드들의 비용을 갱신함(```해당 노드까지의 비용이 더 작으면 갱신```)
4. 후보노드를 visited에 추가하고, 후보노드를 다시 정함
5. 모든 노드를 방문할 때까지 3, 4번 반복


> ### 음의 가중치가 있다면??
>   - 후보노드를 정할 때 최소비용이 갱신될 여지가 없다는 가정이 있음
>   - 음의 가중치가 있다면, 최소비용이 갱신될 여지가 있음
>   - 음의 가중치가 있다면, 벨만-포드 알고리즘을 사용해야 함
  