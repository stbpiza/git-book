# 쿼리 작성 및 최적화

## 11.1 쿼리 작성과 연관된 시스템 변수

### 영문 대소문자 구분
- MySQL 서버는 설치된 운영체제에 따라 테이블명의 대소문자를 구분한다.
- 테이블명을 대소문자 구분 없이 사용하려면 `lower_case_table_names` 시스템 변수를 1로 설정한다.
- 기본적으로 테이블을 생성할 때 대문자 또는 소문자로 통일해서 사용하는 편이 좋다.

### 리터럴 표기법 문자열

#### 문자열
- SQL 표준에서 문자열은 항상 ''를 사용해서 표시한다.
- 하지만 MySQL에서는 ""를 사용해 표기할 수도 있다.
- ``를 사용하면 예약어와의 충돌을 피할 수 있다.

#### 숫자
- 숫자를 상수로 사용할때는 숫자만 사용하면 된다.
- MySQL은 숫자 타입과 문자열 타입 간 비교에서 숫자 타입을 우선시 한다.
- 문자열 값을 숫자 값으로 변환해서 비교를 수행한다.
- 따라서 상수를 문자열 타입인 칼럼과 비교하려면 문자로 표기해서 비교해야 한다.

#### 날짜
- MySQL에서는 정해진 형태의 날짜 포맷으로 표기하면 자동으로 변환해주기 때문에 STR_TO_DATE() 함수를 사용할 필요가 없다.
- `WHERE from_date = '2024-05-02'` 와 같이 사용하면 된다.

#### 불리언
- BOOL이나 BOOLEAN 타입이 있지만 사실 이것은 TINYINT 타입과 같다.
- 0은 FALSE, 1은 TRUE로 간주한다.
- 0과 1 이외의 값은 TRUE FALSE로 조회하면 조회되지 않는다.

#### MySQL 연산자

##### 동등(Equal) 비교(=. <=>)
- 동등 비교는 다른 DBMS와 마찬가지로 `=` 연산자를 사용한다.
- MySQL에서는 `<=>` 연산자를 사용해 동등비교 + NULL값 비교도 할 수 있다.
- NULL 은 is null 연산자 이외에는 비교할 방법이 없지만, `<=>` 연산자를 사용하면 NULL값을 비교할 수 있다.

##### 부정(Not-Equal) 비교(!=, <>)
- 부정 비교는 `!=` 또는 `<>` 연산자를 사용한다.

##### NOT 연산자(!)
- TRUE, FALSE 연산의 결과를 반대로 만다는 연산자로 `NOT`이나 `!`를 사용한다.

##### AND(&&)와 OR(||) 연산자
- 일반적인 DBMS 에서는 `AND`와 `OR` 연산자를 사용하지만 MySQL에서는 `&&`와 `||` 연산자도 사용할 수 있다.
- 하지만 `&&`와 `||` 연산자는 다른 용도로도 사용될 수 있어 `AND`와 `OR` 연산자를 사용하는 것이 가독성이 좋다.
- `AND`와 `OR` 연산자의 우선순위는 `AND`가 `OR`보다 높다.

##### 나누기(/, DIV)와 나머지(%, MOD) 연산자
- 나누기 연산자는 일반적으로 `/`를 사용한다.
- 나눈 몫의 정수 부분만 가져오려면 `DIV`를 사용한다.
- 나눈 나머지를 가져오는 연산자는 `%`와 `MOD`가 있다.

##### REGEXP 연산자
- 정규표현식을 사용해 문자열을 비교할 때 사용하는 연산자이다.
- `REGEXP` 연산자는 `RLIKE` 연산자로도 사용할 수 있다.
- `REGEXP` 연산자를 문자열 칼럼 비교에 사용할 때 인덱스 레인지 스캔을 사용할 수 없다.
- 가능하면 데이터 조회 범위를 줄일 수 있는 다른 조건과 함께 사용하길 권장한다.

##### LIKE 연산자
- DBMS 에서는 `REGEXP` 보다 `LIKE` 연산자를 더 많이 사용한다.
- `LIKE` 연산자는 와일드카드 문자를 사용해 문자열을 비교한다.

> - % : 0 또는 1개 이상의 모든 문자에 일치
> - _ : 정확히 1개 문자에 일치

- `REGEXP` 연산자는 일부만 일치해도 TRUE를 반환하지만 `LIKE`는 처음부터 끝까지 일치해야 TRUE를 반환한다.
- 와일드카드가 검색어 뒤쪽에 있다면 인덱스 레인지 스캔으로 사용할 수 있다.

##### BETWEEN 연산자
- `BETWEEN` 연산자는 크거나 같다와 작거나 같다 두 개의 연산자를 합친 연산자다.
- `BETWEEN` 연산자는 선형으로 인덱스를 검색하고, `IN` 은 동등 비교를 여러 번 수행하는 효과기 때문에 성능이 더 좋다.
- `BETWEEN 3 AND 5` 보다 `IN (3, 4, 5)`가 성능이 더 좋다.

##### IN 연산자
- `IN` 연산자는 여러 개의 값에 대해 동등 비교 연산을 수행하는 연산자다.
- 범위검색이 아닌 여러 번의 동등 비교로 실행되기 때문에 일반적으로 빠르다.
- 다음과 같이 두 형태를 구분할 필요가 있다.
> - 상수가 사용된 경우 - IN (?, ?, ?)
> - 서브쿼리가 사용된 경우 - IN (SELECT ... FROM ...)

- 상수의 경우 매우 빠르게 동작한다.
- MySQL 8.0 이전 버전까지는 IN 절에 튜플(레코드)을 사용하면 항상 풀 테이블 스캔을 했었다.
```mysql
SELECT * 
FROM employees 
WHERE (first_name, last_name) IN (('John', 'Doe'), ('Jane', 'Smith'));
```
- 위와 같이 튜플을 사용하면 과거에는 성능에 문제가 생겨서 쿼리를 쪼개서 여러 번 실행했다.
- MySQL 8.0 이후부터는 IN절에 튜플을 사용해도 인덱스를 사용할 수 있게 되었다.

### MySQL 내장 함수

#### NULL 값 비교 및 대체(IFNULL, ISNULL)
- IFNULL() 함수는 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL이면 대체값을 반환할 수 있다.
- ISNULL() 함수는 칼럼이나 표현식의 값이 NULL인지 비교하고, NULL이면 TRUE(1) 아니면 FALSE(0)를 반환한다.

#### 현재 시각 조회(NOW, SYSDATE)
- NOW() 함수는 하나의 SQL 문에서 여러 번 호출해도 같은 시각을 반환한다.
- SYSDATE() 함수는 호출할 때마다 다른 시각을 반환한다.
- SYSDATE() 함수는 두 가지 큰 잠재적 문제가 있다.
> - SYSDATE() 함수가 사용된 SQL은 레플리카 서버에서 안정적으로 복제되지 못한다.
> - SYSDATE() 함수와 비교되는 칼럼은 인덱스를 효율적으로 사용되지 못한다.

- 일반적인 웹 서비스에서는 NOW() 함수를 사용하는 것이 좋다.

#### 날짜와 시간의 포맷(STR_TO_DATE, DATE_FORMAT)
- 날짜와 시간을 문자열로 변환하거나 문자열을 날짜와 시간으로 변환할 때 사용한다.

```mysql
지정문자 | 내용
-------|-------------------
%Y     | 4자리 연도
%m     | 2자리 월(01 ~ 12)
%d     | 2자리 일(01 ~ 31)
%H     | 2자리 시간(00 ~ 23)
%i     | 2자리 분(00 ~ 59)
%s     | 2자리 초(00 ~ 59)
```

- SQL 표준 형태(YYYY-MM-DD HH:MM:SS)로 입력된 문자열은 필요한 경우 자동으로 DATETIME 타입으로 변환된다.
- 그렇지 않은 형태는 STR_TO_DATE() 함수를 사용해 변환해야 한다.

#### 날짜와 시간의 연산(DATE_ADD, DATE_SUB)
- 날짜와 시간을 더하거나 빼는 연산을 수행할 때 사용한다.
- DATE_ADD() 함수로 더하거나 빼는 처리를 모두 할 수 있기 때문에 DATE_SUB() 함수는 사용하지 않아도 된다.

```mysql
단위         | 의미
------------|-----------------------------
YEAR        | 연도
MONTH       | 월
DAY         | 일
HOUR        | 시간
MINUTE      | 분
SECOND      | 초
MICROSECOND | 마이크로초
QUARTER     | 분기
WEEK        | 주
```