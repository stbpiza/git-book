## 학습 키워드

- API(Application Programming Interface)
- 정보은닉(Information Hiding)과 캡슐화(Encapsulation)
    - 그리고 이 둘의 차이(많이들 혼용하니까 잘 알아두세요)
- Architecture와 Architecture Style의 차이
- REST(7가지 제약 조건 위주로 정리)
    - 교재에 나온 `필딩 제약 조건`을 좀 더 풀어서 정리해보세요.

<hr>

## API(Application Programming Interface)
- API는 소프트웨어 인터페이스라고 볼 수 있으며, 다른 소프트웨어에게 서비스를 제공한다.
- 인터페이스이기 때문에 구현체 내부는 포함되지 않고, 사용 방법에 대한 설명만 제공한다.
- 실제 동작하는 내부는 숨기고 사용에 필요한 부분만 노출시키면서 핵심 기술이나, 취약점 등을 노출시키지 않을 수 있다.
- 우리 서비스를 이용하려면 어떻게 해야하는지 작성한 안내책자라고 생각하면 되겠다.


- 웹 API는 웹 서버, 웹 브라우저를 위한 API다.
- 일반적으로 HTTP 기반 웹 서버를 통해 제공하고 JSON이나 XML을 사용해 요청-응답 메시지 시스템으로 정의되어 있다.
- 구글, 아마존 등 여러가지 서비스에서 제공하는 Open API들이 바로 웹 API다.


## 정보은닉(Information Hiding)과 캡슐화(Encapsulation)

### 정보은닉
- 객체지향에서 정보은닉이란 다른 객체에게 자신의 정보를 숨겨서 외부에서 특정 정보를 알 수 없도록 막는 것을 말한다.
- 정보를 숨기면 의존성을 낮출 수 있고 느슨한 결합을 만들어서 변경에 용이하게 만들 수 있다.
- 내부 정보를 안봐도 되기 때문에 코드를 이해하기 쉽고, 객체단위로 작업하기 편해진다.

### 캡슐화
- 캡슐화는 관련된 요소들을 묶어서 하나의 덩어리로 만들고, 캡슐 내부와 외부의 구분을 명확하게 하는 것을 말한다.
- 데이터를 외부에서 접근하지 못하도록 막고 공용 메소드를 통해서만 접근할 수 있도록 한다.
- 관심사에 맞게 그룹지어서 그룹 단위로 작업이 가능하게 해준다.

### 차이점
- 정보은닉은 내부 요소들을 숨기는 부분에 초점이 맞춰져 있다면,
- 캡슐화는 관련된 요소들을 하나로 묶는 것에 더 관심이 있다.
- 정보은닉의 하나의 방법으로 캡슐화가 있다고 볼 수 있고, 캡슐화를 한다고 반드시 정보은닉이 되지는 않는다.

## Architecture와 Architecture Style의 차이

### Architecture
- 소프트웨어 아키텍처는 유연성, 확장성, 실행가능성, 재사용성, 보안성 같은 소프트웨어 특성들을 
- 기술적, 기능적, 사업적 기대에 맞춰 구조화된 해법으로 바꾸는 과정이다.
- 소프트웨어의 요구 사항, 기대 사항을 주어진 조건, 환경 속에서 효과적으로 달성하기 위해 아키텍처를 활용한다.
- 간단하게 생각하자면 소프트웨어 설계 핵심 구조를 말한다.

### Architecture Style
- 아키텍처 설계에서 반복되는 문제들을 해결하고, 시스템 품질을 달성할 수 있는 방법을 체계화 한 것이다.
- 간단하게 생각하자면 아키텍처 설계에서 사용 가능한 모범 답안이라고 할 수 있다.

## REST(7가지 제약 조건 위주로 정리)

### 1. Starting with the Null Style
- 아무것도 없는 상태에서 시작해라
- 아무런 제약조건 없는 상태에서 시작해서 하나씩 제약조건을 추가하는 방식으로 만들어라
- 그래야 제약조건들이 추가되더라도 기존 상황과 충돌하지 않고 자연스럽게 조화될 수 있다.
- 한 번에 너무 많은 것들을 추가하려고 하는 방식은 안좋다는 의미 같다.

### 2. Client-Server
- 클라이언트-서버 아키텍처 스타일로 만들어라
- 클라이언트는 사용자 인터페이스에 집중하고, 서버는 데이터 관리에 집중하도록 관심사를 분리해라
- 각자의 역할을 나눠서 선택과 집중을 통해 본인의 역할에만 집중할 수 있도록 하라는 의미 같다.

### 3. Stateless
- 클라이언트와 서버간의 통신은 Stateless해라
- Stateless 하다면,
  - 하나의 요청에만 신경쓰면 되기에 가시성(visibility)의 향상이 가능
  - 일부 기능에 문제가 발생했을때 문제 해결에 얽혀있는 것들이 적어지므로 복구가 쉬워지고, 신뢰성(reliablility)의 향상이 가능
  - 요청들을 저장할 필요가 없어서 서버 리소스 확보가 가능해지고 확장성(scalability) 향상이 가능

### 4. Cache
- 응답데이터가 cacheable한지, non-cacheable한지 지정해라
- cacheable한 경우 동일한 요청에 대해 캐시를 활용해 빠른 응답이 가능해진다.
- 서버 리소스, 속도, 사용성 면에서 좋은 효과를 얻을 수 있어서 만든 제약 조건 같다.

### 5. Uniform Interface
- REST의 핵심적인 특징은 REST를 이루는 컴포넌트간의 uniform interface다.
- 전체적으로 일반성(generality)를 적용해서, 시스템을 단순화 시킬 수 있다.
- uniform한 interface를 위한 4가지 제약조건이 있다.

- ### 필딩 제약 조건
- Identification of Resources
  - 리소스 식별자만으로 해당 리소스를 알 수 있게 해야한다.
- Manipulation of Resources through Representations
  - 클라이언트가 이해할 수 있도록 리소스의 현재 상태를 표현해서 응답해야 한다.
- Self-descriptive Messages
  - 클라이언트가 리소스를 어떻게 사용할 수 있는지 모든 설명을 넣어서 응답해야 한다.
  - HTML의 경우 docs 하나로 모든 API를 설명할 수 있어 지키기 쉽지만, 
  - JSON의 경우 API마다 다른 설명이 필요하기에 지키기가 어렵다.
- Hypermedia as the Engine of Application State(HATEOAS)
  - 리소스와 추가로 상호작용하는 방법을 넣어서 응답해야 한다.
  - 쉽게 말하면 응답결과에 하이퍼링크를 넣어서 바로 사용할 수 있도록 알려줘야 한다는 의미이다. 
  - 역시 JSON으로 응답하는 경우 굳이 필요한가 싶기도 하고 하나하나 넣기 번거로워서 잘 지켜지지 않는다.

### 6. Layered System
- Layered System을 사용해서 계층을 분리하여 전체적인 시스템의 복잡도를 감소시키고,
- 독립성을 향상시켜서 시스템 확장성을 향상시킬 수 있다.
- 캡슐화를 활용해서 컴포넌트간 결합도를 낮추고 확장에 열려있는 구조로 만들라는 의미 같다.
### 7. Code-On-Demand
- 스크립트의 형태로 코드를 다운받아 실행할 수 있게 만들어서 클라이언트의 기능을 확장할 수 있게 해야 한다.
- 쉽게 생각하면 자바스크립트를 사용해서 클라이언트 기능을 도와주라는 내용 같다.
- 이 부분은 필수는 아닌 선택적인 제약조건이다.