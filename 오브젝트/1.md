# 객체, 설계

- 이론이 먼저 vs 실무가 먼저
  - 소프트웨어 설계와 유지보수는 실무가 이론보다 앞서 있는 대표적인 분야들
- 이 책은 이론보다는 코드에 집중 할 것이다.


## 1. 티켓 판매 애플리케이션 구현하기
- 상황 가정
  - 이벤트를 통해 무료 입장이 가능한 초대장을 발송
  - 입장 전 이벤트 당첨 여부 확인
  - 이벤트에 당첨된 관람객은 초대장을 티켓으로 교환하고 입장
  - 이벤트에 당첨되지 않은 관람객은 티켓을 구매하고 입장


- 이벤트 당첨자에게 초대장 발송
```java
public class Invitation {
    private LocalDateTime when;
}
```
   
- 공연을 관람하려면 티켓이 필요
```java
public class Ticket {
    private Long fee;
    
    public Long getFee() {
        return fee;
    }
}
```
   
- 관람객이 가지고 올 수 있는 소지품은 초대장, 현금, 티켓 세 가지
- 소지품을 가방에 담는다고 가정
```java
public class Bag {
    private Long amount;
    private Invitation invitation;
    private Ticket ticket;

    public boolean hasInvitation() {
        return invitation != null;
    }
    
    public boolean hasTicket() {
        return ticket != null;
    }
    
    public void setTicket(Ticket ticket) {
        this.ticket = ticket;
    }
    
    public void minusAmount(Long amount) {
        this.amount -= amount;
    }
    
    public void plusAmount(Long amount) {
        this.amount += amount;
    }
}
```

- 가방의 상태는 현금과 초대장을 함께 보관하거나, 초대장 없이 현금만 보관하거나 둘 중 하나
- 생성자에서 제약을 강제하도록 구현
```java
public class Bag {
    public Bag(Long amount) {
        this(null, amount);
    }
    
    public Bag(Invitation invitation, Long amount) {
        this.invitation = invitation;
        this.amount = amount;
    }
}

```

- 관람객을 구현
```java
public class Audience {
    private Bag bag;
        
    public Audience(Bag bag) {
        this.bag = bag;
    }
    
    public Bag getBag() {
        return bag;
    }
}
```

- 매표소를 구현
- 판매할 티켓과 판매 금액을 보관
```java
public class TicketOffice {
    private Long amount;
    private List<Ticket> tickets = new ArrayList<>();
    
    public TicketOffice(Long amount, Ticket ... tickets) {
        this.amount = amount;
        this.tickets.addAll(Arrays.asList(tickets));
    }
    
    public Ticket getTicket() {
        return tickets.remove(0);
    }
    
    public void minusAmount(Long amount) {
        this.amount -= amount;
    }
    
    public void plusAmount(Long amount) {
        this.amount += amount;
    }
}
```

- 판매원을 구현
- 초대장을 티켓으로 교환, 티켓 판매
- 자신이 일하는 매표소에 대한 정보
```java
public class TicketSeller {
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }
    
    public TicketOffice getTicketOffice() {
        return ticketOffice;
    }
}
```


- 소극장을 구현
- 관람객 입장을 처리
```java
public class Theater {
    private TicketSeller ticketSeller;
    
    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }
    
    public void enter(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().setTicket(ticket);
        } else {
            Ticket ticket = ticketSeller.getTicketOffice().getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
            audience.getBag().setTicket(ticket);
        }
    }
}
```

- 이 코드들의 로직은 간단하고 예상대로 동작한다.
- 하지만 몇 가지 문제점이 있다.

## 2. 무엇이 문제인가
- 로버트 마틴의 클린 소프트웨어에서는 소프트웨어 모듈이 가져야 하는 세 가지 기능에 대해 설명한다.
> 첫 번째, 제대로 동작한다.  
> 두 번째, 변경을 위해 존재한다.  
> 세 번째, 코드를 읽는 사람과 의사소통한다.


- 앞에서 작성한 프로그램은 기능은 정확하게 수행하고 있다.
- 하지만 변경 용이성과 읽는 사람과의 의사소통이라는 목적은 만족하지 못한다.


### 예상을 빗나가는 코드
- 마지막에 소개한 Theater 클래스의 enter 메서드가 하는 일을 말로 풀어보자
> 소극장은 관람객의 가방을 열어 그 안에 초대장이 들어있는지 살펴본다.  
> 가방 안에 초대장이 들어 있으면 판매원은 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.   
> 가방 안에 초대장이 들어 있지 않다면 관람객의 가방에서 티켓 금액만큼의 현금을 꺼내 매표소에 적립한 후에,   
> 매표소에 보관돼 있는 티켓을 관람객의 가방 안으로 옮긴다.

- 문제는 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재라는 점이다.
- 소극장에서 관람객의 가방을 마음대로 열어보는 것이 문제이다.
- 그리고 판매원이 아닌 소극장이 티켓과 현금에 직접 접근하는 것도 문제이다.
- 구현한 동작이 현실과 달라서 제대로 의사소통하지 못하고 있다. 


- 그리고 enter 메서드는 하나의 메서드가 너무 많은 세부사항을 다루고 있어 코드를 이해하기 어렵게 만든다.

### 변경에 취약한 코드
- 가장 심각한 문제는 Audience와 TicketSeller를 변경하려면 Theater도 함께 변경해야 한다는 점이다.
- 이 코드는 관람객이 현금과 초대장을 보관하기 위해 항상 가방을 들고 다닌다고 가정한다.
- 또한 판매원이 매표소에서만 티켓을 판매한다고 가정한다.
- 관람객이 가방을 들고 있지 않다면? 관람객이 현금이 아닌 카드로 결제해야 한다면?
- 판매원이 매표소 밖에서 티켓을 판매해야 한다면?
- 이런 가정이 깨지는 순간 모든 코드가 일시에 흔들리게 된다.


- 다른 클래스가 Audience 내부에 대해 많이 알면 알수록 Audience를 변경하기 어려워진다.
- 이것은 객체 사이의 ```의존성(dependency)```과 관련된 문제다.
- 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체에 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다.
- 그렇다고 해서 의존성을 완전히 없애는 것이 정답은 아니다.
- 우리의 목표는 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.


- 객체 사이의 의존성이 과한 경우에 ```결합도(coupling)```가 높다고 말한다.
- 두 객체 사이의 결합도가 높으면 함께 변경될 확률이 높아서 변경이 어려워진다.

## 3. 설계 개선하기
- 코드를 이해하기 어려운 이유는 Theater가 관람객의 가방과 판매원의 매표소에 직접 접근하기 때문이다.
- 의도를 정확하게 의사소통하지 못하기 때문에 코드가 이해하기 어려워진 것이다.
- Theater가 관람객의 가방과 매표소에 직접 접근한다는 것은 결합된다는 것을 의미한다.


- 해결 방법은 간단하다. 
- Theater가 관람객의 가방과 판매원의 매표소에 관해 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다.
- 생각해보면 Theater가 관람객의 가방과 판매원의 매표소에 대해 알아야 할 필요가 없다.
- Theater가 원하는 것은 관람객이 소극장에 입장하는 것뿐이다.
- 관람객과 판매원이 각자의 역할을 스스로 수행하도록 자율적인 존재로 만들면 된다.

### 자율성을 높이자
- 첫 번째 단계는 Theater의 enter 메서드에서 TicketOffice에 접근하는 모든 코드를 TicketSeller 내부로 숨기는 것이다.

```java
public class TicketSeller {
    private TicketOffice ticketOffice;
    
    public TicketSeller(TicketOffice ticketOffice) {
        this.ticketOffice = ticketOffice;
    }
    
    public void sellTo(Audience audience) {
        if (audience.getBag().hasInvitation()) {
            Ticket ticket = ticketOffice.getTicket();
            audience.getBage().setTicket(ticket);
        } else {
            Ticket ticket = ticketOffice.getTicket();
            audience.getBag().minusAmount(ticket.getFee());
            ticketOffice.plusAmount(ticket.getFee());
            audience.getBage().setTicket(ticket);
        }
    }
}
```

- TicketSeller에서 getTicketOffice 메서드가 제거되었다.
- ticketOffice의 가시성이 private이고 접근 가능한 퍼블릭 매서드가 없기 때문에 외부에서 직접 접근할 수 없다.
- 따라서 TicketSeller가 TicketOffice에서 티켓 관리하는 일을 스스로 수행해야 한다.


- 이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 ```캡슐화(encapsulation)```라고 한다.


- 이제 Theater는 TicketSeller의 sellTo 메서드를 호출하면 된다.
```java
public class Theater {
    private TicketSeller ticketSeller;
    
    public Theater(TicketSeller ticketSeller) {
        this.ticketSeller = ticketSeller;
    }
    
    public void enter(Audience audience) {
        ticketSeller.sellTo(audience);
    }
}
```

- 이제 Theater는 TicketSeller의 내부 구현을 몰라도 된다.
- Theater는 sellTo 메서드만 호출하면 된다.


- Theater는 오직 TicketSeller의 ```인터페이스에(interface)```만 의존하게 되었다.
- TicketSeller가 내부에 TicketOffice 인스턴스를 포함하고 있다는 사실은 ```구현(implementation)```의 영역에 속한다.