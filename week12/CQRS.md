## 학습 키워드

- CQS
- CQRS
- SSOT(Single Source Of Truth)
- Materialized View
- OLTP(Online Transaction Processing)
- OLAP(Online Analytical Processing)
- Event Sourcing

<hr>

## CQS
> Command Query Separation
- 조회는 쿼리
- 변경은 커맨드
- 쿼리와 커맨드를 분리하는 것
- 쿼리와 커맨드를 분리하지 않으면 조회하려다가 변경이 일어나는 등 예상하지 못한 부작용이 발생할 수 있다.
## CQRS
> Command Query Responsibility Segregation
- 읽기와 쓰기를 다른 모델로 분리하는 디자인 패턴
- 일반적인 CRUD는 동일한 모델을 사용하지만, 복잡한 도메인에서는 읽기와 쓰기를 분리하는 것이 유리할 수 있다.
- 분리하면 쓰기 모델은 쓰기 성능에 맞게, 읽기 모델은 읽기 성능에 맞게 최적화할 수 있다.
- 장점
  - 읽기와 쓰기가 분리되어 있어 개별 확장이 가능하다.
  - 복잡한 비즈니스 로직은 쓰기에 몰아두고 읽기는 단순하게 유지할 수 있다.
  - 읽기와 쓰기에 별도의 보안 설정이 가능하다.
  - 읽기와 쓰기에 다른 데이터베이스를 사용할 수 있다.
  - 이벤트 소싱을 지원한다.
- 단점
  - 구현이 복잡해지기 때문에 정말 필요한 경우에만 사용하는 것이 좋다.
## SSOT(Single Source Of Truth)
> 데이터를 한 곳에만 저장하는 데이터 관리 개념
- 조직이나 시스템에서 특정 정보의 공식적이고 신뢰할 수 있는 출처가 된다.
- 데이터가 여러 시스템에 분산되어 있는 복잡한 환경에서 중요하게 여겨지는 개념이다.
- 장점
  - 동일한 데이터의 여러 버전이 서로 다른 곳에 존재할 가능성이 없기 때문에 데이터 일관성과 정확성이 향상된다.
  - 데이터 혼동과 정보 중복을 줄여 데이터 무결성을 높일 수 있다.
  - 데이터를 한 곳에만 저장하므로 데이터를 관리하기 쉽다.
## Materialized View
> 조회 성능을 향상시키기 위해 미리 계산된 뷰
- 실시간으로 데이터를 계산하는 일반 뷰와 달리 Materialized View는 데이터를 쿼리하고 새로 고쳐질 시점에 결과를 저장한다.
- 복잡하고 시간이 많이 걸리는 쿼리의 결과가 미리 계산되어 저장되므로 데이터에 더 빠르게 액세스할 수 있다.
- 데이터 검색 속도가 중요한 시스템에서 사용하면 좋다.
- 하지만 물리적으로 저장하기 때문에 일반 뷰보다 저장비용이 높고, 데이터 새로고침 시간이 오래 걸릴 수 있어 데이터의 실시간성이 중요한 경우에는 사용하기 어렵다.
## OLTP(Online Transaction Processing)
> 트랜잭션 지향 애플리케이션을 관리하는 시스템
- 실시간 트랜잭션 처리를 위해 설계됨
- 삽입, 업데이트, 삭제와 같은 짧은 온라인 트랜잭션이 많다.
- 매우 빠른 쿼리 처리, 다중 액세스 환경에서의 데이터 무결성 유지, 초당 트랜잭션 수로 측정되는 효율성에 중점을 두고 있다.
## OLAP(Online Analytical Processing)
> 비즈니스 의사 결정을 위한 데이터 분석을 제공하는 소프트웨어 도구
- 여러 데이터베이스 시스템의 데이터베이스 정보를 한 번에 분석할 수 있도록 설계되었다.
- 특정 기간 동안의 판매량 합산과 같이 복잡하고 집계가 필요한 분석 쿼리에 대한 빠른 답변을 제공하는 것이 목적이다.
## OLTP와 OLAP의 차이점
- OLTP 시스템은 모든 종류의 쿼리(읽기, 삽입, 업데이트, 삭제)를 처리하는 반면, 
- OLAP은 읽기 작업에 최적화되어 있다.
- OLTP는 운영 데이터 처리에 더 중점을 두며 비즈니스의 일상적인 트랜잭션에 초점을 맞추는 반면, 
- OLAP는 데이터 분석에 더 중점을 두며 비즈니스가 정보에 입각한 의사 결정을 내릴 수 있도록 지원하는 데 중점을 둔다.
## Event Sourcing
> 애플리케이션의 상태를 이벤트 시퀀스로 유지한다는 아이디어를 중심으로 하는 소프트웨어 아키텍처 패턴
- 데이터의 현재 상태만 저장하는 것이 아니라, 데이터의 변경 이벤트 과정을 모두 저장한다.
- 이벤트를 재생하면 언제든지 데이터의 현재 상태를 얻을 수 있다.
- 장점
  - 데이터를 변경하는 모든 이벤트를 저장하기 때문에 데이터의 변경 이력을 추적할 수 있다.
  - 오류가 발생해도 언제든지 데이터의 현재 상태를 다시 만들 수 있다.
  - 시간을 거슬러 올라갈 수 있고, 과거 상태를 쉽게 복원할 수 있다.
- 하지만 이벤트를 재생하는 과정이 복잡하고, 버전 관리 등 추가적인 작업이 필요하다.
- 단순 CRUD 애플리케이션에서는 사용하기 부적합하고, 데이터 변경 이력을 추적해야 하는 경우에 사용하기 좋다.
