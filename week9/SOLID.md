## 학습 키워드

- SOLID (객체 지향 설계)
    - SRP (Single Responsibility Principle, 단일 책임 원칙)
    - OCP (Open-Closed Principle, 개방-폐쇄 원칙)
    - LSP (Liskov Substitution Principle, 리스코프 치환 원칙)
    - ISP (Interface Segregation Principle, 인터페이스 분리 원칙)
    - DIP (Dependency Inversion Principle, 의존관계 역전 원칙)


<hr>

## SOLID (객체 지향 설계)
> 객체 지향 설계의 5가지 원칙
- SOLID 원칙은 객체 지향 프로그래밍과 설계의 다섯 가지 기본 원칙을 말한다. 
- SOLID 원칙들은 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링할 수 있는 지침이다.
### SRP (Single Responsibility Principle, 단일 책임 원칙)
> 한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.
- 이 원칙은 클래스나 모듈이 변경되어야 할 이유가 하나만 있어야 한다는 것으로, 책임이 하나만 있어야 한다는 것을 의미한다. 
- 코드의 관심사를 더 잘 분리하여 유지 관리와 이해가 더 쉬워지도록 하는 것을 목표로 한다.
- 클래스에 두 개 이상의 책임이 있는 경우 한 책임의 변경이 다른 책임에 영향을 미칠 수 있기 때문에 SRP를 위반한다고 볼 수 있다.
- 코드에서 서로 다른 책임을 찾고 이를 다른 클래스로 분리하는 것이 SRP를 지키는 길이다.
- 장점
  - 코드의 응집도를 높여서 코드의 가독성을 높인다.
  - 책임이 분리되어 있어 코드 유지보수에 유리하다.
  - 하나의 책임만 있으므로 테스트 코드 작성이 쉽다.
  - 코드를 재사용하기 쉽다.
### OCP (Open-Closed Principle, 개방-폐쇄 원칙)
> 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다는 것을 의미한다.
- 이 원칙은 변경 시 시스템의 안정성을 유지하는 데 도움이 되며 모듈식으로 확장 가능한 아키텍처의 사용을 도와준다.
- 상속이나 인터페이스, 추상 클래스 등을 사용해서 구현할 수 있다.
- 장점
  - 기존의 코드를 변경하지 않아도 되므로 코드의 유지보수에 유리하다.
  - 코드의 모듈화가 쉬워진다.
  - 확장에 열려있으므로 유연성이 향상된다.
  - 수정 없이 확장이 가능해 코드의 재사용성이 높아진다.
### LSP (Liskov Substitution Principle, 리스코프 치환 원칙)
> 서브타입(subtype)은 그것의 기반 타입(base type)으로 치환 가능해야 한다.
- 이 원칙은 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 것을 의미한다.
- 즉, 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행해야 한다는 것이다.
- 상속이 올바르게 사용되도록 보장하고 관련 클래스 간에 동작의 일관성을 유지하는 데 도움이 된다.
- 장점
  - 자식 클래스가 부모 클래스의 기능을 유지하므로 코드를 이해하기 쉽다.
  - 특정 기능에 의존하는게 아닌, 부모 클래스나 인터페이스를 활용하므로 결합도가 낮아진다.
  - 자식 클래스가 부모 클래스의 기능을 확장하므로 코드의 재사용성이 높아진다.
### ISP (Interface Segregation Principle, 인터페이스 분리 원칙)
> ISP는 응집력이 없는 커다란 인터페이스를 여러 개의 작은 인터페이스로 나눌 것을 제안한다.
- 이 원칙은 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다는 것을 의미한다.
- 즉, 인터페이스를 클라이언트에 특화되도록 분리시키라는 것이다.
- 이렇게 하면 시스템의 여러 부분 간의 결합을 줄이고 유지보수성을 개선하는 데 도움이 된다.
- 장점
  - 인터페이스를 작게 분리함으로써 구성 요소 간의 결합도를 낮춘다.
  - 작고 응집도가 높은 인터페이스는 이해하기 쉽다.
  - 인터페이스가 작을수록 구현해야 하는 메소드 수가 적어 구현이 쉽다.
  - 여러 인터페이스를 사용하면 교체나 확장이 쉬워진다.
### DIP (Dependency Inversion Principle, 의존관계 역전 원칙) 
> 1. 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다.
> 2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화에 의존해야 한다.
- 주요 목표는 보다 유연하고 분리된 아키텍처를 구현하여 전체 시스템에 영향을 주지 않고 구성 요소를 교체하거나 구현을 변경하기가 더 쉬워지도록 하는 것이다.
- 이 원칙은 의존성 주입(Dependency Injection)을 통해 구현할 수 있다.
- 장점
  - 추상화에 의존하면서 구성 요소 간의 결합도를 낮춘다.
  - 구현에 의존하지 않으므로 더 쉽게 변경할 수 있다.
  - 추상화를 사용하면 테스트에서 목킹을 통해 단위 테스트를 쉽게 작성할 수 있다.
  - 상위 수준 모듈, 추상화, 하위 수준 모듈이 명확하게 분리되어 코드가 깔끔해진다.