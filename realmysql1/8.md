# 인덱스

## 8.1 디스크 읽기 방식

- SSD의 등장으로 디스크 I/O 속도가 예전보다 빨라졌지만, 여전히 컴퓨터에서 가장 느린 작업이다.
- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 많다.

### 랜덤 I/O와 순차I/O

- 랜덤 I/O: 디스크의 임의 위치에 접근하는 것
- 순차 I/O: 디스크의 연속된 위치에 접근하는 것 (랜덤 I/O보다 빠르다)
- 디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 사용할 위치로 옮기는 시간에 크게 영향을 받는다.
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿀 수 있는 방법은 별로 없다.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.
- 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 말한다.

## 8.2 인덱스

- 인덱스는 책의 맨 끝에 있는 색인과 같다.
- 데이터를 잘 정렬해서 보관하여 원하는 데이터를 빠르게 찾을 수 있도록 도와준다.
- 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 INSERT, UPDATE, DELETE 성능은 느려지지만 SELECT 성능은 매우 빨라진다.
- 쓰기 성능을 어디까지 희생할 수 있는지, 읽기 성능을 얼마나 높이고 싶은지를 잘 고려해서 인덱스를 설계해야 한다.

### 프라이머리 키, 보조 키(세컨더리 인덱스)

- `프라이머리 키`는 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미한다.
- 이 칼럼(혹은 칼럼의 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 `식별자`라고도 부른다.
- NULL 값이 허용되지 않으며, 중복될 수 없다.
- 프라이머리 키를 제외한 나머지 인덱스는 `세컨더리 인덱스`로 분류한다.
- 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체해서 사용할 수 있어서 `대체 키`라고도 하고 그냥 세컨더리 인덱스라고 하기도 한다.

### B-Tree 인덱스, Hash 인덱스

- B-Tree 인덱스는 데이터베이스에서 가장 많이 사용되는 인덱스 알고리즘이다.
- 상당히 오래되었고 그만큼 성숙해진 상태다.
- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스는 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
- 하지만 값을 변형하기 때문에 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.
- Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

### 유니크 인덱스, 논-유니크 인덱스

- 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지, 더 많이 존재하는지 여부이지만,
- 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 1건의 레코드만 찾으면 되는지 여부를 알려주기 때문에 중요하다.

## 8.3 B-Tree 인덱스

- B-Tree 인덱스는 데이터베이스에서 가장 오래되었고, 아직도 많이 사용되는 인덱스 알고리즘이다.
- B 는 Binary가 아닌 Balanced를 의미한다.
- B-Tree의 기본 구조는 최상위에 하나의 `루트 노드`가 존재하고 그 하위에 자식 노드가 붙어있는 형태다.
- 가장 하위에 있는 노드를 `리프 노드`라 하고 중간의 노드를 `브랜치 노드`라고 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소를 가지고 있다.
- MyISAM 테이블 인덱스는 세컨더리 인덱스가 물리적인 주소를 가지고 있고, InnoDB 테이블은 프라이머리 키를 가지고 주소처럼 사용한다.(논리적인 주소)
- 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 경우, 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
- 이 작업으로 인해 InnoDB 스토리지 엔진을 사용하는 테이블은 성능이 떨어질 것 처럼 보이지만 각자 장단점이 있다.

### B-Tree 인덱스 키 추가 및 삭제

- MyISAM, MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 가 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 추가한다.
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 필요하다면 작업일 지연시켜 나중에 처리할 수 있다. (체인지 버퍼)
- 하지만 프라이머리 키가 유니크 인덱스의 경우에는 중복 체크가 필요하기 때문에 즉시 처리한다.
- 새로운 인덱스 키가 추가될때는 적절한 위치를 찾아서 리프 노드에 저장하는데, 리프 노드가 꽉찬 경우에는 리프 노드 분리 작업이 필요하다. (비용이 많이 든다)
- 삭제하는 경우에는 실제로 삭제하지 않고 삭제 마크만 남기고 끝난다.
- 삭제 마킹된 공간은 그대로 방치하거나 재활용할 수 있다.
- 키를 변경하는 경우에는 값이 바뀌면서 저장될 리프 노드 위치가 달라질 수 있어서, 삭제 후 새로 추가하는 방식으로 처리한다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

#### 1. 인덱스 키 값의 크기
- InnoDB 스토리지 엔진은 디스크에 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
- 또한 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.
- 인덱스도 결국은 페이지 단위로 관리되며, 루트와 브랜치, 그리고 리프 노드를 구분한 기준이 바로 페이지 단위다.
- 일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적이며, MySQL의 경우는 인덱스의 페이지 크기와 키 값에 따라 결정된다.
- 페이지 크기는 4KB ~ 64KB 사이에서 선택할 수 있으며, 기본값은 16KB이다.
- 인덱스의 키가 16바이트, 자식 노드 주소 영역이 12바이트라고 가정해보면,
- 페이지 크기가 16KB인 경우, 하나의 인덱스의 페이지에는 16*1024/(16+12) = 585개의 키를 저장할 수 있다.
- 인덱스 키 값을 32바이트로 늘리면 16*1024/(32+12) = 372개의 키를 저장할 수 있다.
- 결국 인덱스를 구성하는 키 값의 크기가 커지면 한 페이지에 저장할 수 있는 키의 개수가 줄어들어서 디스크 읽기 작업 수가 늘어나고, 그만큼 느려지게 된다.
- 또한 인덱스 키 값의 길이가 길어지면 전체적인 인덱스 크기가 커지게 되고, 메모리에 캐시해 둘 수 있는 레코드 수가 줄어들면서 메모리 효율이 떨어진다.

#### 2. B-Tree 깊이
- 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.
- 깊이가 3인경우, 키 값이 16바이트면 최대 2억(585^3)개의 키 값을 담을 수 있고, 32바이트면 5천만(372^3)개로 줄어든다.
- 인덱스의 키 값이 증가하면 하나의 인덱스 페이지가 담을 수 있는 개수가 적어지고, 인덱스의 깊이가 깊어지게 된다.
- 하지만 실제로는 아무리 대용량 데이터베이스라도 깊이가 5단계 이상 깊어지는 경우는 흔치 않다.

#### 3. 선택도(기수성)
- 인덱스에서 선택도(Selectivity)와 기수성(Cardinality)은 거의 같은 의미로 사용되며, 인덱스의 키 중에 중복되지 않는 값의 개수를 의미한다.
- 인덱스 키 값이 100인데, 유니크한 값의 수가 10개라면 기수성은 10이다.
- 기수성이 높을수록 인덱스의 효율이 높아지고, 기수성이 낮을수록 인덱스의 효율이 떨어진다.

#### 4. 읽어야 하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 읽는 것보다 높은 비용이 드는 작업이다.
- 인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있다.
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 직접 읽는 것보다 4~5배 비융이 더 많이 드는 작업인 것으로 예측한다.
- 즉 인덱스를 통해 읽어야 할 레코드의 건수가 전체 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 효율적이다.

### B-Tree 인덱스를 통한 데이터 읽기

- 어떤 경우에 인덱스를 사용하게 유도할지, 사용하지 못하게 할지 판단하려면 각 스토리지 엔진이 어떻게 인덱스를 이용하는지 알아야 한다.

#### 1. 인덱스 레인지 스캔
- 인덱스의 접근 방법 가운데 가장 대표적인 접근 방식이다. 
- 검색해야 할 인덱스의 범위가 결정됐을때 사용하는 방식이다.
- B-Tree 인덱스에서 루트와 브랜치 노드를 이용해 스캔 시작 위치를 검색하고, 필요한 방향(오름차순, 내림차순)으로 인덱스로 읽어나가는 과정이다.
- 중요한 것은 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다는 것이다.
- 별도의 정렬 과정이 필요한 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 된다.
- 또 한 가지 중요한 것은 인덱스의 리프 노드에서 검색 조건에 일치하는 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다는 것이다.
- 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 건별로 랜덤 I/O가 발생하므로 비용이 많이 든다.
- 그래서 인덱스를 통해 읽어야 할 데이터 레코드가 20~25%를 넘으면 인덱스 없이 직접 데이터를 읽는 것이 더 효율적이다.
- 인덱스 레인지 스캔은 다음과 같이 크게 3단계를 거친다.

> 1. 인덱스에서 조건을 만족하는 값이 지정된 위치를 찾는다. (인덱스 탐색 index seek)
> 2. 1번에서 탐색된 위치부터 필요한 만큼 인덱스를 차례대로 읽는다. (인덱스 스캔 index scan) (1과 2를 합쳐서 인덱스 스캔이라고 하기도 함)
> 3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어온다.

- 쿼리가 필요로 하는 데이터에 따라 3번 과정은 필요하지 않을 수도 있는데, 이를 `커버링 인덱스`라고 한다.
- 커버링 인덱스는 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 줄어들고 성능은 그만큼 빨리진다.

#### 2. 인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀 스캔이라고 한다.
- 대표적으로 쿼리에 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.
- 예를 들어 인덱스는 (A, B, C) 순서로 만들어져 있지만 쿼리의 조건절은 B나 C로 검색하는 경우다.
- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.
- 일반적으로 인덱스 풀 스캔을 사용하면 "인덱스를 사용하지 못한다", "인덱스를 효율적으로 사용하지 못한다" 라고 표현한다.

#### 3. 루스 인덱스 스캔
- 오라클 같은 DBMS의 "인덱스 스킵 스캔"과 작동 방식이 비슷하다.
- 앞의 두 가지 방법과 다르게 느슨하게, 듬성듬성하게 인덱스를 읽는 것을 의미한다.
- 인덱스 레인지 스캔과 비슷하게 작동하지만 중간에 필요치 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용된다.
```mysql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```
- 인덱스가 (dept_no, emp_no)로 구성되어 있을 때, dept_no 그룹별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.
- 즉 인덱스에서 WHERE 조건을 만족하는 전체 범위를 다 스캔할 필요가 없다는 것을 옵티마이저가 알고 있기 때문에 조건에 안맞는 레코드는 무시하고 다음 레코드로 이동한다.

#### 4. 인덱스 스킵 스캔
- 인덱스의 핵심은 값이 정렬돼 있다는 것이며, 이로 인해 인덱스를 구성하는 칼럼의 순서가 매우 중요하다.
- 예를 들어 (gender, birth_date)로 인덱스가 구성되어 있다면, gender 없이 birth_date만 비교 조건에 있으면 인덱스를 사용할 수 없었다.
- MySQL 8.0 부터는 옵티마이저가 gender 칼럼을 건너뛰어서 birth_date만으로도 인덱스를 사용할 수 있게 해주는 인덱스 스킵 스캔 최적화 기능이 도입됐다.
- 8.0 이전 버전에서도 루스 인덱스 스캔 기능이 있었지만, GROUP BY 에서만 사용이 가능했었다.
- 인덱스 스킵 스캔을 사용하면 gender 칼럼에서 유니크한 값을 모두 조회해서 주어진 쿼리에 gender 칼럼의 조건을 추가해서 쿼리를 다시 실행하는 형태로 처리한다.
- 새롭게 도입된 게능이어서 아직 단점이 있다.
> - WHERE 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
> - 쿼리가 인덱스에 존재하는 칼럼만으로 처리 가능해야 함(커버링 인덱스)
- 만약 유니크한 값의 개수가 매우 많다면 인덱스에서 스캔해야 할 시작 지점을 검색하는 작업이 많이 필요해지고, 오히려 성능이 더 느려질 수 있다.
- 그리고 gender, birth_date 이외의 나머지 칼럼도 조회하도록 쿼리가 작성되면 인덱스 스킵 스캔이 불가능해지고 풀 테이블 스캔이 진행된다.
- 하지만 이 단점은 이후에 옵티마이저가 개선되면 해결될 수 있을 것으로 예상된다.

### 다중 칼럼 인덱스 (Multi-Column Index)
- 두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 한다.
- 인덱스의 두 번째 칼럼은 첫 번째 칼럼에 의존해서 정렬돼 있다.
- 즉 두 번째 칼럼의 정렬은 첫 번째 칼럼이 똑같은 레코드에서만 의미가 있다.
- 다중 칼럼 인덱스에서는 인덱스 내의 칼럼 순서가 상당히 중요하며, 아주 신중히 결정해야 한다.

### B-Tree 인덱스의 정렬 및 스캔 방향
- 일반적인 DBMS에서는 인덱스를 생성하는 시점에 인덱스를 구성하는 각 칼럼의 정렬을 오름차순, 내림차순으로 설정할 수 있다.
- 인덱스가 오름차순으로 정렬되어 있어도, 역순으로 접근해서 내림차순으로 읽을 수 있다.
- 그렇다면 언제 인덱스 정렬이 중요할까?
- InnoDB 스토리지 엔진에서는 아래의 이유 때문에 인덱스 역순 스캔이 인덱스 정순 스캔에 비해 느리다.
> - 페이지 잠금이 인덱스 정순 스캔에 적합한 구조로 되어있다.
> - 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조로 되어있다.
- 일반적으로 인덱스를 ORDER BY DESC 하는 쿼리가 많이 사용되지 않으면 내림차순 인덱스를 고려할 필요는 없다.
- 하지만 빈번하게 사용된다면 내림차순 인덱스가 더 효율적이라고 볼 수 있다.
- 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는 데 도움이 된다.

### B-Tree 인덱스의 가용성과 효율성 
- 쿼리의 WHERE 조건이나 GROUP BY, ORDER BY 절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 알아야 한다.

#### 1. 비교 조건의 종류와 효율성
```mysql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no>=10114;
```

> - 케이스 A: INDEX (dept_no, emp_no)
> - 케이스 B: INDEX (emp_no, dept_no)

- 케이스 A 인덱스는 dept_no='d002' AND emp_no>=10114 인 레코드를 찾고, 그 이후에는 dept_no가 'd002'가 아닐 때까지 인덱스를 쭉 읽기만 하면 된다.
- 이 경우 읽은 레코드가 모두 사용자가 원하는 결과이다. 꼭 필요한 비교 작업만 수행한 것이므로 상당히 효율적으로 인덱스를 이용한 것이다.
- 하지만 케이스 B 인덱스는 emp_no>=10114 AND dept_no='d002' 인 레코드를 찾고, 그 이후 모든 레코드에 대해 dept_no가 'd002'인지 비교해야 한다.
- 즉 불필요한 비교 작업이 많이 발생하므로 효율적이지 못하다.
- 이처럼 인덱스를 통해 읽은 레코드가 나머지 조건에 맞는지 비교하면서 취사선택하는 작업을 `필터링`이라고 한다.
- 이런 현상이 발생한 이유는 다중 칼럼 인덱스의 정렬 방식 때문이다. (인덱스의 N번째 키 값은 N-1번째 키 값에 대해서 다시 정렬됨)
- 케이스 A에서 2번째 칼럼인 emp_no는 비교 작업의 범위를 좁히는데 도움을 준다.
- 하지만 케이스 B에서 2번째 칼럼인 dept_no는 비교 작업의 범위를 좁히는 데 아무런 도움을 주지 못하고, 쿼리 조건에 맞는지 검사하는 용도로만 사용된다.
- 공식 명칭은 아니지만 케이스 A의 조건과 같이 작업의 범위를 결정하는 조건을 `작업 범위 결정 조건`이라고 하고
- 케이스 B의 조건과 같이 비교 작업의 범위를 줄이지 못하고 단순히 거름종이 역할만 하는 조건을 `필터링 조건` 혹은 `체크 조건` 이라고 표현한다.
- 케이스 B에서 emp_no만 작업 범위 결정 조건이고 dept_no는 필터링 조건으로 사용된 것이다.
- 


#### 2. 인덱스의 가용성
- B-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬돼 있다는 것이다.
- 따라서 `LIKE '%mer'` 같은 WHERE 조건은 인덱스를 사용할 수 없다. 가장 왼쪽 글자부터 비교해야 하기 때문이다.
- 또한 다중 칼럼 인덱스에서 선행 칼럼 조건 없이는 인덱스를 사용할 수 없다.


#### 3. 가용성과 효율성 판단

- B-Tree 특성상 다음 조건에서는 인덱스를 사용할 수 없다. (작업 범위 결정 조건으로 사용할 수 없다는 의미)

> - NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
> - LIKE '%??' 같은 와일드카드가 왼쪽에 붙은 경우
> - 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우 (SUBSTRING, DAYOFMONTH 등)
> - NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우 (deterministic_function())
> - 데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)
> - 문자열 데이터 타입의 콜레이션이 다른 경우

- 일반적인 DBMS에서는 NULL 값이 인덱스에 저장되지 않지만 MySQL에서는 NULL 값도 인덱스에 저장된다.
- IS NULL 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.
- 다중 칼럼 인덱스는 어떤 조건에서 사용될 수 있고, 사용될 수 없는지 알아보자.
```mysql
INDEX ix_test ( column_1, column_2, column_3, ..., column_n )
```
> - 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
>   - column_1 칼럼에 대한 조건이 없는 경우
>   - column_1 칼럼의 비교 조건이 인ㄷ게스 사용 불가 조건 중 하나인 경우
> - 작업 범위 결정 조건으로 인덱스를 사용하는 경우 (column_1부터 column_i까지는 작업 범위 결정 조건 사용, 이후로는 체크 조건)
>   - column_1 ~ column_(i-1) 칼럼까지 동등 비교 형태로 비교 (=, IN)
>   - column_i 칼럼에 대해 다음 연산자 중 하나로 비교 (=, IN, >, <, LIKE '?%')


## 8.4 R-Tree 인덱스
- R-Tree 인덱스는 2차원의 공간 데이터를 다루는 데 사용되는 알고리즘이다.
- 기본적이니 내부 매커니즘은 B-Tree와 흡사하다.
- MySQL의 공간 확장에는 아래의 세 가지 기능이 포함돼 있다.
> - 공간 데이터를 저장할 수 있는 데이터 타입
> - 공간 데이터의 검색을 위한 공간 인덱스(R-Tree 인덱스)
> - 공간 데이터의 연산 함수(거리 또는 포함 관계의 처리)

- 현재 출시되는 버전의 MySQL에서는 거리를 비교하는 ST_Distance(), ST_Distance_Sphere() 함수는 공간 인덱스를 효율적으로 사용하지 못한다.
- ST_Contains(), ST_Witnin() 같은 함수를 사용해 공간 인덱스를 사용할 수 있다.

## 8.5 전문 검색 인덱스
- 지금까지의 인덱스는 크지 않은 데이터 또는 이미 키워드화한 작은 값에 대한 인덱싱 알고리즘이었다.
- B-Tree 인덱스는 실제 칼럼의 값이 1MB라도 전체를 인덱스 키로 사용하지 않고 1000바이트(MyISAM), 3072바이트(InnoDB)까지만 잘라서 사용한다.
- 또한 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능하다.
- 문서의 내용 전체를 인덱스화해서 검색할 수 있는 전문 검색(Full Text search) 인덱스가 필요하다.

### 인덱스 알고리즘
- 전문 검색에서는 본문에서 검색하게 될 키워드를 분석해 내고 해당 키워드로 인덱스를 구축한다.
- 문서의 키워드를 인덱싱하는 기법에 따라 크게 `단어의 어근 분석`과 `n-gram 분석` 알고리즘으로 구분할 수 있다.

#### 1. 어근 분석 알고리즘
- MySQL 서버의 전문 검색 인덱스는 다음과 같은 두 가지 중요한 과정을 거쳐서 색인 작업이 수행된다,
> - 불용어(Stop Word) 처리
> - 어근 분석(Stemming)

- 불용어 처리는 검색에 사용되지 않는 단어를 제거하는 작업이다.
- 불용어의 개수가 많지 않기 때문에 모두 상수로 정의해서 사용하는 경우가 많다.
- MySQL에서는 불용어가 소스코드에 정의돼 있지만, 사용자가 정의할 수 있는 기능도 있다.
- 어근 분석은 검색어로 선정된 단어의 뿌리인 원형을 찾는 작업이다.
- MySQL에서는 오픈소스 형태도 분석 라이브러리인 MeCab을 플러그인 형태로 사용할 수 있게 지원한다.
- 한글이나 일본어의 경우 단어의 변형 자체는 거의 없어서 어근 분석보다는 문장의 형태소를 분석해서 명사와 조사를 구분하는 기능이 더 중요하다.
- MeCab은 일본어를 위한 형태소 분석 프로그램이지만 그나마 한국어는 일본어와 많이 비슷하기 때문에 사용이 가능하다.
- 하지만 제대로 작동하려면 언어의 샘플을 이용해 언어를 학습하는 과정이 필요한데, 많은 시간과 노력이 필요하다.

#### 2. n-gram 분석 알고리즘
- MeCab은 만족할 만한 결과를 내기 위해 많은 노력과 시간이 필요하다. 전문적인 검색 엔진이 아니라면 적용하기 쉽지 않다.
- 이러한 단점을 보완하기 위해 n-gram 분석 알고리즘이 등장했다.
- n-gram은 무조건 문자열을 n개씩 잘라서 인덱싱하는 방법이다.
- 알고리즘이 단순하고 국가별 언어에 대한 이해와 준비 작업이 필요 없는 반면, 인덱스의 크기는 상당히 크다.
- 일반적으로 2글자 단위로 쪼개는 2-gram 방식이 많이 사용된다.
- 단어들은 2글자씩 중첩해서 토큰으로 분리하고, 불용어가 포함된 토큰들을 제외하고 인덱싱한다.

#### 불용어 변경 및 삭제 
- 불용어의 경우 불용어가 포함된 토큰도 모두 제외되기 때문에 사용자를 혼란스럽게 만들 수 있다.
- 때문에 불용어 자체를 무시하거나, 사용자가 직접 불용어를 등록하는 방법을 권장한다.
```mysql
ft_stopword_file = ''
```
- 불용어를 삭제하는 방법은 위와같이 시스템 변수를 수정하는 것이다. (MySQL 서버 재시작 필요)
```mysql
SET GLOBAL innodb_ft_enable_stopword = OFF;
```
- 위와같은 명령어를 사용하면 InnoDB 테이블에 대해서만 불용어 처리를 하지 않게 된다.
```mysql
ft_stopword_file = '/data/my_custom_stopword.txt'
```
- 위와같이 사용자 정의 불용어 파일을 지정할 수도 있다.
```mysql
SET GLOBAL innodb_ft_server_stopword_table = 'mydb/my_stopword';
```
- InnoDB 테이블에 대해서만 사용 가능한 불용어 목록 테이블을 시스템 변수에 저장할 수도 있다.

### 전문 검색 인덱스의 가용성
- 전문 검색 인덱스를 사용하려면 반드시 다음 두 가지 조건을 갖춰야 한다.
> - 쿼리 문장이 전문 검색을 위한 문법(MATCH ... AGAINST)을 사용
> - 테이블이 전문 검색 대상 칼럼에 대해서 전문 인덱스 보유

- B-Tree 인덱스 처럼 `LIKE '00%'` 조건을 걸면 풀 테이블 스캔으로 처리된다.
- 반드시 MATCH() AGAINST() 구문으로 쿼리를 작성해야 한다.

## 8.6 함수 기반 인덱스
- 칼럼의 값을 변형해서 만들어진 값에 대해 인덱스를 생성하는 방법이다. 크게 두 가지 방법이 있다.
> - 가상 칼럼을 이용한 인덱스
> - 함수를 이용한 인덱스

### 가상 칼럼을 이용한 인덱스
```mysql
ALTER TABLE user
ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,
ADD INDEX ix_full_name (full_name);
```
- MySQL 8.0 부터는 위와 같이 가상 컬럼을 추가하고 인덱스를 생성할 수 있게 되었다.
- 가상 칼럼이 VIRTUAL 이나 STORED 옵션 둘 다 인덱스 생성이 가능하다.
- 테이블에 새로운 칼럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블 구조가 변경된다는 단점이 있다.

### 함수를 이용한 인덱스 
- MySQL 8.0 부터는 테이블의 구조를 변경하지 않고 함수를 직접 사용하는 인덱스를 생성할 수 있게 됐다.
```mysql
CREATE TABLE user (
    user_id BIGINT,
    first_name VARCHAR(10),
    last_name VARCHAR(10),
    PRIMARY KEY (user_id),
    INDEX ix_full_name ((CONCAT(first_name, ' ', last_name)))
);
```
- 함수 기반 인덱스를 제대로 활용하려면 반드시 조건절에 함수 기반 인덱스에 명시된 표현식이 그대로 사용돼야 한다.
- 가상 칼럼과 함수 기반 둘 다 내부적으로 동일한 구현 방법을 사용하기 때문에 성능 차이는 없다.