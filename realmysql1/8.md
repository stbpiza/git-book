# 인덱스

## 8.1 디스크 읽기 방식

- SSD의 등장으로 디스크 I/O 속도가 예전보다 빨라졌지만, 여전히 컴퓨터에서 가장 느린 작업이다.
- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 많다.

### 랜덤 I/O와 순차I/O

- 랜덤 I/O: 디스크의 임의 위치에 접근하는 것
- 순차 I/O: 디스크의 연속된 위치에 접근하는 것 (랜덤 I/O보다 빠르다)
- 디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 사용할 위치로 옮기는 시간에 크게 영향을 받는다.
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿀 수 있는 방법은 별로 없다.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.
- 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 말한다.

## 8.2 인덱스

- 인덱스는 책의 맨 끝에 있는 색인과 같다.
- 데이터를 잘 정렬해서 보관하여 원하는 데이터를 빠르게 찾을 수 있도록 도와준다.
- 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 INSERT, UPDATE, DELETE 성능은 느려지지만 SELECT 성능은 매우 빨라진다.
- 쓰기 성능을 어디까지 희생할 수 있는지, 읽기 성능을 얼마나 높이고 싶은지를 잘 고려해서 인덱스를 설계해야 한다.

### 프라이머리 키, 보조 키(세컨더리 인덱스)

- `프라이머리 키`는 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미한다.
- 이 칼럼(혹은 칼럼의 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 `식별자`라고도 부른다.
- NULL 값이 허용되지 않으며, 중복될 수 없다.
- 프라이머리 키를 제외한 나머지 인덱스는 `세컨더리 인덱스`로 분류한다.
- 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체해서 사용할 수 있어서 `대체 키`라고도 하고 그냥 세컨더리 인덱스라고 하기도 한다.

### B-Tree 인덱스, Hash 인덱스

- B-Tree 인덱스는 데이터베이스에서 가장 많이 사용되는 인덱스 알고리즘이다.
- 상당히 오래되었고 그만큼 성숙해진 상태다.
- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스는 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
- 하지만 값을 변형하기 때문에 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.
- Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

### 유니크 인덱스, 논-유니크 인덱스

- 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지, 더 많이 존재하는지 여부이지만,
- 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 1건의 레코드만 찾으면 되는지 여부를 알려주기 때문에 중요하다.

## 8.3 B-Tree 인덱스

- B-Tree 인덱스는 데이터베이스에서 가장 오래되었고, 아직도 많이 사용되는 인덱스 알고리즘이다.
- B 는 Binary가 아닌 Balanced를 의미한다.
- B-Tree의 기본 구조는 최상위에 하나의 `루트 노드`가 존재하고 그 하위에 자식 노드가 붙어있는 형태다.
- 가장 하위에 있는 노드를 `리프 노드`라 하고 중간의 노드를 `브랜치 노드`라고 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소를 가지고 있다.
- MyISAM 테이블 인덱스는 세컨더리 인덱스가 물리적인 주소를 가지고 있고, InnoDB 테이블은 프라이머리 키를 가지고 주소처럼 사용한다.(논리적인 주소)
- 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 경우, 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
- 이 작업으로 인해 InnoDB 스토리지 엔진을 사용하는 테이블은 성능이 떨어질 것 처럼 보이지만 각자 장단점이 있다.

### B-Tree 인덱스 키 추가 및 삭제

- MyISAM, MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 가 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 추가한다.
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 필요하다면 작업일 지연시켜 나중에 처리할 수 있다. (체인지 버퍼)
- 하지만 프라이머리 키가 유니크 인덱스의 경우에는 중복 체크가 필요하기 때문에 즉시 처리한다.
- 새로운 인덱스 키가 추가될때는 적절한 위치를 찾아서 리프 노드에 저장하는데, 리프 노드가 꽉찬 경우에는 리프 노드 분리 작업이 필요하다. (비용이 많이 든다)
- 삭제하는 경우에는 실제로 삭제하지 않고 삭제 마크만 남기고 끝난다.
- 삭제 마킹된 공간은 그대로 방치하거나 재활용할 수 있다.
- 키를 변경하는 경우에는 값이 바뀌면서 저장될 리프 노드 위치가 달라질 수 있어서, 삭제 후 새로 추가하는 방식으로 처리한다.