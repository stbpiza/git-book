# 인덱스

## 8.1 디스크 읽기 방식

- SSD의 등장으로 디스크 I/O 속도가 예전보다 빨라졌지만, 여전히 컴퓨터에서 가장 느린 작업이다.
- 데이터베이스 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건일 때가 많다.

### 랜덤 I/O와 순차I/O

- 랜덤 I/O: 디스크의 임의 위치에 접근하는 것
- 순차 I/O: 디스크의 연속된 위치에 접근하는 것 (랜덤 I/O보다 빠르다)
- 디스크에 데이터를 쓰고 읽는 데 걸리는 시간은 디스크 헤더를 움직여서 사용할 위치로 옮기는 시간에 크게 영향을 받는다.
- 쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿀 수 있는 방법은 별로 없다.
- 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O 자체를 줄여주는 것이 목적이다.
- 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 말한다.

## 8.2 인덱스

- 인덱스는 책의 맨 끝에 있는 색인과 같다.
- 데이터를 잘 정렬해서 보관하여 원하는 데이터를 빠르게 찾을 수 있도록 도와준다.
- 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 INSERT, UPDATE, DELETE 성능은 느려지지만 SELECT 성능은 매우 빨라진다.
- 쓰기 성능을 어디까지 희생할 수 있는지, 읽기 성능을 얼마나 높이고 싶은지를 잘 고려해서 인덱스를 설계해야 한다.

### 프라이머리 키, 보조 키(세컨더리 인덱스)

- `프라이머리 키`는 그 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미한다.
- 이 칼럼(혹은 칼럼의 조합)은 테이블에서 해당 레코드를 식별할 수 있는 기준값이 되기 때문에 `식별자`라고도 부른다.
- NULL 값이 허용되지 않으며, 중복될 수 없다.
- 프라이머리 키를 제외한 나머지 인덱스는 `세컨더리 인덱스`로 분류한다.
- 유니크 인덱스는 프라이머리 키와 성격이 비슷하고 대체해서 사용할 수 있어서 `대체 키`라고도 하고 그냥 세컨더리 인덱스라고 하기도 한다.

### B-Tree 인덱스, Hash 인덱스

- B-Tree 인덱스는 데이터베이스에서 가장 많이 사용되는 인덱스 알고리즘이다.
- 상당히 오래되었고 그만큼 성숙해진 상태다.
- 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스는 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘으로, 매우 빠른 검색을 지원한다.
- 하지만 값을 변형하기 때문에 일부만 검색하거나 범위를 검색할 때는 사용할 수 없다.
- Hash 인덱스는 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

### 유니크 인덱스, 논-유니크 인덱스

- 인덱스가 유니크한지 아닌지는 단순히 같은 값이 1개만 존재하는지, 더 많이 존재하는지 여부이지만,
- 실제 DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 1건의 레코드만 찾으면 되는지 여부를 알려주기 때문에 중요하다.

## 8.3 B-Tree 인덱스

- B-Tree 인덱스는 데이터베이스에서 가장 오래되었고, 아직도 많이 사용되는 인덱스 알고리즘이다.
- B 는 Binary가 아닌 Balanced를 의미한다.
- B-Tree의 기본 구조는 최상위에 하나의 `루트 노드`가 존재하고 그 하위에 자식 노드가 붙어있는 형태다.
- 가장 하위에 있는 노드를 `리프 노드`라 하고 중간의 노드를 `브랜치 노드`라고 한다.
- 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소를 가지고 있다.
- MyISAM 테이블 인덱스는 세컨더리 인덱스가 물리적인 주소를 가지고 있고, InnoDB 테이블은 프라이머리 키를 가지고 주소처럼 사용한다.(논리적인 주소)
- 그래서 InnoDB 테이블에서 인덱스를 통해 레코드를 읽을 경우, 프라이머리 키 값을 이용해 프라이머리 키 인덱스를 한 번 더 검색한 후 프라이머리 키 인덱스의 리프 페이지에 저장돼 있는 레코드를 읽는다.
- 이 작업으로 인해 InnoDB 스토리지 엔진을 사용하는 테이블은 성능이 떨어질 것 처럼 보이지만 각자 장단점이 있다.

### B-Tree 인덱스 키 추가 및 삭제

- MyISAM, MEMORY 스토리지 엔진을 사용하는 테이블에서는 INSERT 가 실행되면 즉시 새로운 키 값을 B-Tree 인덱스에 추가한다.
- InnoDB 스토리지 엔진을 사용하는 테이블에서는 필요하다면 작업일 지연시켜 나중에 처리할 수 있다. (체인지 버퍼)
- 하지만 프라이머리 키가 유니크 인덱스의 경우에는 중복 체크가 필요하기 때문에 즉시 처리한다.
- 새로운 인덱스 키가 추가될때는 적절한 위치를 찾아서 리프 노드에 저장하는데, 리프 노드가 꽉찬 경우에는 리프 노드 분리 작업이 필요하다. (비용이 많이 든다)
- 삭제하는 경우에는 실제로 삭제하지 않고 삭제 마크만 남기고 끝난다.
- 삭제 마킹된 공간은 그대로 방치하거나 재활용할 수 있다.
- 키를 변경하는 경우에는 값이 바뀌면서 저장될 리프 노드 위치가 달라질 수 있어서, 삭제 후 새로 추가하는 방식으로 처리한다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

1. 인덱스 키 값의 크기
- InnoDB 스토리지 엔진은 디스크에 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다.
- 또한 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.
- 인덱스도 결국은 페이지 단위로 관리되며, 루트와 브랜치, 그리고 리프 노드를 구분한 기준이 바로 페이지 단위다.
- 일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적이며, MySQL의 경우는 인덱스의 페이지 크기와 키 값에 따라 결정된다.
- 페이지 크기는 4KB ~ 64KB 사이에서 선택할 수 있으며, 기본값은 16KB이다.
- 인덱스의 키가 16바이트, 자식 노드 주소 영역이 12바이트라고 가정해보면,
- 페이지 크기가 16KB인 경우, 하나의 인덱스의 페이지에는 16*1024/(16+12) = 585개의 키를 저장할 수 있다.
- 인덱스 키 값을 32바이트로 늘리면 16*1024/(32+12) = 372개의 키를 저장할 수 있다.
- 결국 인덱스를 구성하는 키 값의 크기가 커지면 한 페이지에 저장할 수 있는 키의 개수가 줄어들어서 디스크 읽기 작업 수가 늘어나고, 그만큼 느려지게 된다.
- 또한 인덱스 키 값의 길이가 길어지면 전체적인 인덱스 크기가 커지게 되고, 메모리에 캐시해 둘 수 있는 레코드 수가 줄어들면서 메모리 효율이 떨어진다.

2. B-Tree 깊이
- 깊이는 상당히 중요하지만 직접 제어할 방법은 없다.
- 깊이가 3인경우, 키 값이 16바이트면 최대 2억(585^3)개의 키 값을 담을 수 있고, 32바이트면 5천만(372^3)개로 줄어든다.
- 인덱스의 키 값이 증가하면 하나의 인덱스 페이지가 담을 수 있는 개수가 적어지고, 인덱스의 깊이가 깊어지게 된다.
- 하지만 실제로는 아무리 대용량 데이터베이스라도 깊이가 5단계 이상 깊어지는 경우는 흔치 않다.

3. 선택도(기수성)
- 인덱스에서 선택도(Selectivity)와 기수성(Cardinality)은 거의 같은 의미로 사용되며, 인덱스의 키 중에 중복되지 않는 값의 개수를 의미한다.
- 인덱스 키 값이 100인데, 유니크한 값의 수가 10개라면 기수성은 10이다.
- 기수성이 높을수록 인덱스의 효율이 높아지고, 기수성이 낮을수록 인덱스의 효율이 떨어진다.

4. 읽어야 하는 레코드의 건수

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 읽는 것보다 높은 비용이 드는 작업이다.
- 인덱스를 이용한 읽기의 손익 분기점이 얼마인지 판단할 필요가 있다.
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 직접 읽는 것보다 4~5배 비융이 더 많이 드는 작업인 것으로 예측한다.
- 즉 인덱스를 통해 읽어야 할 레코드의 건수가 전체 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않는 것이 효율적이다.

### B-Tree 인덱스를 통한 데이터 읽기

- 