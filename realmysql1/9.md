# 옵티마이저와 힌트

- MySQL에서 쿼리를 최적으로 실행하기 위해 옵티마이저의 실행 계획과 힌트에 대해 알아본다.

## 9.1 개요
- 어떤 DBMS든지 쿼리의 실행 계획을 수립하는 옵티마이저는 가장 복잡한 부분으로 알려져 있으며,
- 옵티마이저가 만들어 내는 실행 계획을 이해하는 것 또한 상당히 어려운 부분이다.
- 하지만 실행 계획을 이해할 수 있어야지만 더 최적화된 방법으로 실행 계획을 유도할 수 있다.

### 쿼리 실행 절차
- MySQL 서버에서 쿼리가 실행되는 과정은 크게 세 단계로 나눌 수 있다.
> 1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리(파스 트리)한다.
> 2. SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 읽을지 선택한다.
> 3. 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

- 첫 번째 단계를 `SQL 파싱`이라고 하며, MySQL서버의 `SQL 파서`라는 모듈로 처리한다.
- SQL 문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다.
- 이 단계에서 `SQL 파스 트리`가 만들어지며, MySQL 서버는 이를 이용해 쿼리를 실행한다.
    

- 두 번째 단계는 첫 번째 단계에서 만들어진 SQL 파스 트리를 참조하면서 다음과 같은 내용을 처리한다.
> - 불필요한 조건 제거 및 복잡한 연산의 단순화
> - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
> - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스를 결정
> - 가져온 레코드를 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 두 번째 단계는 `최적화 및 실행 계획 수립`단계이며, 옵티마이저에서 처리한다.
- 이 단계가 완료되면 쿼리의 `실행 계획`이 수립된다.
   

- 세 번째 단계는 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고, 
- MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

### 옵티마이저의 종류
- 옵티마이저는 데이터베이스 서버에서 두뇌와 같은 역할을 담당한다.
- 옵티마이저는 현재 대부분의 DBMS가 선택하고 있는 `비용 기반 최적화(CBO, Cost-Based Optimization)`와 `규칙 기반 최적화(RBO, Rule-Based Optimization)`로 나뉜다.

#### 규칙 기반 최적화
> - 규칙 기반 최적화는 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식을 의미한다.
> - 이 방식에서는 통계 정보를 조사하지 않고 실행 계획이 수립되기 때문에 같은 쿼리에 대해서는 거의 항상 같은 실행 방법을 만들어 낸다.
> - 하지만 사용자의 데이터는 분포도가 매우 다양하기 때문에 규칙 기반의 최적화는 이미 오래전부터 거의 사용되지 않는다.

#### 비용 기반 최적화
> - 비용 기반 최적화는 쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고, 
> - 각 단위 작업의 비용(부하) 정보와 대상 테이블의 예측된 통계 정보를 이용해 실행 계획별 비용을 산출한다.
> - 방법별로 비용이 최소로 소요되는 처리 방식을 선택해 최종적으로 쿼리를 실행한다.

## 9.2 기본 데이터 처리
- 모든 RDBMS는 기본 데이터 가공 기능을 가지고 있다.
- 하지만 결과물은 동일하더라도 그 과정은 천차만별이다.
- MySQL 서버가 어떤 알고리즘을 사용하는지 간단히 살펴보자.

### 풀 테이블 스캔과 풀 인덱스 스캔
- MySQL 옵티마이저는 다음과 같은 조건일때 주로 풀 테이블 스캔을 선택한다.
> - 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
> - WHERE 절이나 ON 절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
> - 인덱스 레인지 스캔을 사용할 수 있는 쿼리라고 하더라도 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우
- 일반적으로 테이블의 전체 크기는 인덱스보다 훨씬 크기 때문에 테이블을 처음부터 끝까지 읽는 작업은 상당히 많은 디스크 읽기가 필요하다.
- InnoDB 테이블에서는 `리드 어헤드(Read ahead)` 작업을 통해 미리 데이터 페이지를 디스크에서 읽어서 버퍼 풀에 가져다 둔다.
- 이렇게 함으로써 풀 테이블 스캔을 할 때 속도를 높일 수 있다.

### 병렬 처리
- MySQL 8.0 부터 용도가 한정돼 있긴 하지만 쿼리의 병렬 처리가 가능해졌다.
- 여기서 말하는 병렬 처리는 하나의 쿼리를 여러 스레드가 작업을 나누어 동시에 처리한다는 것을 의미한다.
- `innodb_parallel_read_threads` 시스템 변수를 이용해 병렬 처리를 조절할 수 있다.
- 아직은 쿼리를 여러 개의 스레드를 이용해 병렬로 처리하게 하는 힌트나 옵션은 없다.
- 아무런 WHERE 조건 없이 단순히 테이블의 전체 건수를 가져오는 쿼리만 병렬로 처리할 수 있다.
```mysql
SET SESSION innodb_parallel_read_threads = 4;
SELECT COUNT(*) FROM salaries;
```
- 병렬 처리용 스레드 개수가 늘어날수록 쿼리 처리에 걸리는 시간이 줄어든다.
- 하지만 CPU 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수도 있으니 주의해야 한다.

### ORDER BY 처리
- 정렬을 처리하는 방법은 인덱스를 이용하는 방법과 쿼리가 실행될 때 `Filesort`라는 별도의 처리를 이용하는 방법이 있다.

#### 인덱스 이용
> - 장점
>   - INSERT, UPDATE, DELETE 쿼리가 실행될 때 이미 인덱스가 정렬돼 있어서 순서대로 읽기만 하면 되므로 매우 빠르다.
> - 단점
>   - INSERT, UPDATE, DELETE 작업 시 부가적인 인덱스 추가/삭제 작업이 필요하므로 느리다.
>   - 인덱스 때문에 디스크 공간이 더 많이 필요하다.
>   - 인덱스 개수가 늘어날수록 InnoDB 버퍼 풀을 위한 메모리가 많이 필요하다.

#### Filesort 이용
> - 장점
>   - 인덱스를 생성하지 않아도 되므로 인덱스를 이용할 때의 단점이 장점으로 바뀐다.
>   - 정렬해야 할 레코드가 많지 않으면 메모리에서 Filesort가 처리되므로 충분히 빠르다.
> - 단점
>   - 정렬 작업이 쿼리 실행 시 처리되므로 레코드 대상 건수가 많아질수록 쿼리의 응답 속도가 느리다.

- 다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기가 어렵다.
> - 정렬 기준이 너무 많아서 요건별로 모두 인덱스를 생성하는 것이 불가능한 경우
> - GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
> - UNION의 결과가 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
> - 랜덤하게 결과 레코드를 가져와야 하는 경우

- MySQL 서버에서 인덱스를 이용하지 않고 별도의 정렬 처리를 수행했는지는 실행 계획의 Extra 칼럼에 `Using filesort`라고 표시되는지 여부로 판단한다.

#### 소트 버퍼
- MySQL 서버는 정렬 작업을 위해 별도의 메모리 공간을 할당받아서 사용한다.
- 이 메모리 공간을 `소트 버퍼(Sort Buffer)`라고 한다.
- 소트 버퍼의 크기는 `sort_buffer_size` 시스템 변수로 조절할 수 있다.
- 정렬해야 할 레코드가 소량이어서 메모리에 할당된 소트 버퍼만으로 정렬할 수 있다면 이상적이다.
- 하지만 소트 버퍼에 모든 레코드를 담을 수 없는 경우에는 레코드를 여러 조각으로 나눠 디스크에 임시 파일을 만들어서 정렬 작업을 수행한다.
- 각 버퍼 크기만큼 정렬된 레코드를 다시 병합하면서 정렬을 수행해야 하는데, 이 작업을 `멀티 머지(Multi-merge)`라고 표현한다.
- 이 작업들이 모두 디스크의 쓰기와 읽기를 유발한다.
- sort_buffer_size를 늘리면 무조건 빨라진다고 생각할 수 있지만 그렇지 않다.
- 리눅스 계열 운영체제에서는 너무 큰 사아즈를 사용하는 경우, 큰 메모리 공간 할당 때문에 성능이 훨씬 떨어질 수 있다.
- 일반적으로 소트 버퍼의 크기는 56KB에서 1MB 사이로 설정하는 것이 좋다.
- 소트 버퍼는 세션(로컬) 메모리 영역이기 때문에 커넥션이 많을수록 메모리 사용량이 늘어난다.
- 소트 버퍼의 크기를 10MB 이상으로 설정하면 메모리 부족 현상이 발생해 서버가 다운될 수 있다.

#### 정렬 알고리즘
- 레코드를 정렬할 때 레코드 전체를 소트 버퍼에 담을지 또는 정렬 기준 칼럼만 소트 버퍼에 담을지에 따라 `싱글 패스`와 `투패스`로 나눌 수 있다.
- 옵티마이저 트레이스 기능을 통해 정렬 알고리즘을 확인할 수 있다. (`sort_mode` 필드)
> - <sort_key, rowid> : 정렬 키와 레코드의 로우 아이디(Row ID)만 가져와서 정렬하는 방식
> - <sort_key, additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 고정 사이즈 메모리 저장
> - <sort_key, packed_additional_fields> : 정렬 키와 레코드 전체를 가져와서 정렬하는 방식으로, 레코드의 칼럼들은 가변 사이즈 메모리 저장
- 여기서 첫 번째 방식을 투 패스 정렬방식이라 하고, 두 번째 세번째 방식을 싱글 패스 정렬방식이라 한다.

##### 싱글 패스 정렬
- 소트 버퍼에 정렬 기준 칼럼을 포함해 SELECT 대상이 되는 칼럼 전부를 담아서 정렬을 수행하는 정렬 방식이다.
```mysql
SELECT emp_no, first_name, last_name 
FROM employees 
ORDER BY first_name;
```
- 위 쿼리는 first_name을 기준으로 정렬하는데, 정렬에 필요하지 않은 칼럼도 포함해 emp_no, first_name, last_name을 모두 소트 버퍼에 담아서 정렬한다.

##### 투 패스 정렬
- 정렬 대상 칼럼과 프라이머리 키 값만 소트 버퍼에 담아서 정렬하고, 정렬된 순서대로 다시 프라이머리 키 값으로 레코드를 찾아서 정렬된 순서대로 가져오는 정렬 방식이다.
- 싱글 패스 정렬이 도입되기 이전부터 사용해왔던 정렬 방식이다.
- 투 패스 방식은 테이블을 두 번 읽어야 하기 때문에 상당히 불합리하지만 싱글 패스는 이러한 불합리가 없다.
- 하지만 싱글 패스 방식은 더 많은 소트 버퍼 공간이 필요하다.
   

- 최신 버전에서는 일반적으로 싱글 패스 정렬 방식을 주로 사용한다.
- 하지만 다음의 경우 싱글 패스 정렬 방식을 사용하지 못한다.
> - 레코드의 크기가 max_length_for_sort_data보다 큰 경우
> - BLOB, TEXT 같은 데이터 타입이 SELECT 대상에 포함된 경우

- 얼핏 생각해보면 투 패스 정렬 방식이 더 빠를 것도 같지만 항상 그렇지 않다.
- 레코드의 크기나 건수가 작은 경우 싱글 패스 방식이 더 빠르다.
- SELECT 쿼리에서 *을 통해 모든 칼럼을 가져오도록 하면 정렬 버퍼를 비효율 적으로 사용할 수 있으니 주의해야 한다.

#### 정렬 처리 방법
- 쿼리에 ORDER BY가 사용되면 반드시 다음 3가지 처리 방법 중 하나로 처리된다.
- 일반적으로 아래쪽에 있는 방법으로 갈수록 속도가 떨어진다.
> 정렬 처리 방법 : 실행 계획의 Extra 칼럼 내용
> - 인덱스를 사용한 정렬 : 별도 표기 없음
> - 조인에서 드라이빙 테이블만 정렬 : "Using filesort"
> - 조인에서 조인 결과를 임시 테이블로 저장 후 정렬 : "Using temporary; Using filesort"

- 먼저 옵티마이저는 정렬 처리를 위해 인덱스를 이용할 수 있을지 검토한다.
- 인덱스를 사용할 수 있다면 Filesrot를 사용하지 않고 인덱스를 이용한 정렬을 수행한다.
- 인덱스를 사용할 수 없다면 WHERE 조건에 일치하는 레코드를 검색해 정렬 버퍼에 저장하면서 정렬을 처리할 것이다.
- 이때 옵티마이저는 정렬 대상 레코드를 최소화하기 위해 다음 2가지 방법 중 하나를 선택한다.
> - 조인의 드라이빙 테이블만 정렬한 다음 조인을 수행
> - 조인이 끝나고 일치하는 레코드를 모두 가져온 후 정렬을 수행 
- 일반적으로 조인이 수행되면서 레코드 건수와 크기는 배수로 불어나기 때문에 가능하다면 드라이빙 테이블만 정렬한 다음 조인을 하는 방법이 좋다.

##### 인덱스를 이용한 정렬
- 인덱스를 이용한 정렬을 위해서는 반드시 ORDER BY에 명시된 칼럼이 제일 먼저 읽는 테이블에 속하고
- ORDER BY의 순서대로 생성된 인덱스가 있어야 한다.
- 또한 WHERE 절에 첫 번째로 읽는 테이블의 칼럼에 대한 조건이 있다면, 그 조건과 ORDER BY는 같은 인덱스를 사용할 수 있어야 한다.
- 그리고 B-Tree 계열의 인덱스가 아니면 인덱스를 이용한 정렬을 사용할 수 없다.
- 여러 테이블이 조인되는 경우에는 네스티드-루프(Nested-loop) 방식의 조인에서만 사용할 수 있다.
   

- 인덱스를 이용해 정렬이 처리되는 경우에는 값이 이미 정렬돼 있기 때문에 순서대로 읽기만 하면 된다.
- 하지만 조인이 사용된 쿼리의 실행 계획에 조인 버퍼(Join buffer)가 사용된다면 순서가 흐트러질 수 있기 때문에 주의해야 한다.

##### 조인의 드라이빙 테이블마나 정렬
- 일반적으로 조인이 수행되면 레코드의 건수가 몇 배로 불어나고 레코드의 크기도 커진다.
- 그래서 조인을 실행하기 전에 첫 번째 테이블의 레코드를 먼저 정렬한 다음 조인을 실행하는 것이 차선책이 될 것이다.
- 이 방법으로 처리되려면 첫 번째 테이블의 칼럼만으로 ORDER BY 절을 작성해야 한다.

##### 임시 테이블을 이용한 정렬
- 2개 이상의 테이블을 조인해서 그 결과를 정렬해야 한다면 임시 테이블이 필요할 수도 있다.
- 조인의 결과를 임시 테이블에 저장하고, 그 결과를 다시 정렬하는 과정을 거친다.
- 이 방법은 3가지 정렬 방법 중 가장 느린 정렬 방법이다.


##### 정렬 처리 방법의 성능 비교
- 주로 웹 서비스용 쿼리에서는 ORDER BY 와 함께 LIMIT를 함께 사용하는 경향이 있다.
- 일반적으로 LIMIT는 일부만 가져오기 때문에 작업량을 줄여주지만, ORDER BY나 GROUP BY는 일부만 가져와서 처리할 수 없다.
- 조건을 만족하는 모든 레코드를 가져와서 작업을 하고 그 후에 LIMIT를 적용할 수 있다.
- 그래서 WHERE 조건을 잘 지정해도, 잘못된 ORDER BY나 GROUP BY 때문에 성능이 느려질 수 있다.

##### 스트리밍 방식
- 서버 쪽에서 처리할 데이터가 얼마인지에 관계없이 조건에 일치하는 레코드가 검색될때마다 바로바로 클라이언트로 전송해주는 방식
- 클라이언트는 쿼리를 요청하고 바로 첫 번째 레코드를 전달받는다. 물론 마지막 레코드는 언제 받을지 알 수 없지만 중요하지 않다.
- 웹 서비스 같은 OLTP 환경에서는 쿼리의 요청에서부터 첫 번째 레코드를 전달받게 되기까지의 응답 시간이 중요하다.
- 스트리밍 방식으로는 얼마나 많은 레코드를 조회하느냐에 상관없이 빠른 응답 시간을 보장한다.

##### 버퍼링 방식
- ORDER BY나 GROUP BY를 사용하면 스트리밍 방식으로 처리할 수 없다.
- 모든 레코드를 정렬하고 그루핑 하는 동안 클라이언트는 기다려야 하기 때문에 응답 속도가 느려진다.
- 그래서 스트리밍의 반대 표현으로 버퍼링이라고 한다.

> 참고
> - JDBC 라이브러리를 사용하면 MySQL 서버가 스트리밍 방식을 사용해도 JDBC 라이브러리가 버퍼링 방식으로 처리한다.
> - JDBC 자체 버퍼에 레코드를 쌓아두고 마지막 레코드가 전달되면 그제서야 클라이언트로 전송한다.
> - 전체 처리 시간이 짧아지고, MySQL 서버와의 통신 횟수가 적어 자원 소모가 줄어들기 때문에 이런 방식으로 동작한다.
> - 아주 대량의 데이터를 가져와야 할 때는 스트리밍 방식으로 수동으로 변경할 수 있다.

- ORDER BY 3가지 처리 방법 중 인덱스를 사용한 정렬 방식만 스트리밍 방식으로 처리할 수 있다.
- 조인과 함께 ORDER BY 절과 LIMIT 절이 사용될 경우 가능하다면 인덱스를 사용한 정렬로 유도하고, 안되면 드라이빙 테이블만 정렬해도 되는 수준으로 유도하는게 좋다.

#### 정렬 관련 상태 변수
- MySQL 서버는 처리하는 주요 작업에 대해서는 해당 작업의 실행 횟수를 상태 변수로 저장한다.
- 몇 건의 레코드나 정렬 처리를 수행했는지, 소트 버퍼 간의 병합 작업은 몇 번이나 발생했는지 등을 확인할 수 있다.
```mysql
FLUSH STATUS;
SHOW STATUS LIKE 'sort%';
+-------------------+--------+
| Variable_name     | Value  |
+-------------------+--------+
| Sort_merge_passes | 13     |
| Sort_range        | 0      |
| Sort_rows         | 300024 |
| Sort_scan         | 0      |
+-------------------+--------+
```
- Sort_merge_passes : 멀티 머지 처리 횟수
- Sort_range : 레인지 스캔 처리 횟수
- Sort_rows : 정렬한 레코드 건수
- Sort_scan : 풀 테이블 스캔 처리 횟수

### GROUP BY 처리
- GROUP BY 역시 스트리밍 방식으로 처리할 수 없다.
- HAVING 절을 사용하면 GROUP BY 결과에 필터링 역할을 수행한다.
- GROUP BY에 사용된 조건은 인덱스를 사용해서 처리될 수 없으므로 HAVING 절을 튜닝하려고 인덱스를 고민할 필요는 없다.
   

- GROUP BY 작업도 인덱스를 사용하는 경우와 아닌 경우로 나눌 수 있다.
- 인덱스를 이용할 때는 인덱스 스캔 방법과 루스 인덱스 스캔 방법으로 나뉜다.
- 인덱스를 사용하지 못하는 쿼리에서 GROUP BY 작업은 임시 테이블을 사용한다.

#### 인덱스 스캔을 이용하는 GROUP BY(타이트 인덱스 스캔)
- 조인의 드라이빙 테이블에 속한 칼럼만 이용해 그루핑할 때 GROUP BY 칼럼으로 이미 인덱스가 있다면,
- 그 인덱스를 차례대로 읽으면서 그루핑 작업을 수행하고 그 결과로 조인을 처리한다.
- 이러한 그루핑 방식을 사용하는 쿼리의 실행 계획에서는 Extra 칼럼에 별도로 GROUP BY 관련 코멘트가 표시되지 않는다.

#### 루스 인덱스 스캔을 이용하는 GROUP BY
- 인덱스르 레코드를 건너뛰면서 필요한 부분만 읽어서 가져오는 방법으로, 실행 계획 Extra 칼럼에 "Using index for group-by" 코멘트가 표시된다.
   

- 아래의 예시를 살펴보자
- salaries 테이블의 인덱스는 (emp_no, from_date)로 생성되어 있다.

```mysql
EXPLAIN
SELECT emp_no
FROM salaries
WHERE from_date='1985-03-01'
GROUP BY emp_no;
```
```mysql
+----+----------+-------+---------+---------------------------------------+
| id | table    | type  | key     | Extra                                 |
+----+----------+-------+---------+---------------------------------------+
|  1 | salaries | range | PRIMARY | Using where; Using index for group-by |
+----+----------+-------+---------+---------------------------------------+
```
- 이 쿼리를 어떻게 실행했는지 순서대로 하나씩 살펴보자
> 1. (emp_no, from_date) 인덱스를 차례대로 스캔하면서 emp_no의 첫 번째 유일한 값(그룹 키) "10001"을 찾아낸다.
> 2. (emp_no, from_date) 인덱스에서 emp_no가 "10001"인 것 중에서 from_date가 '1985-03-01'인 레코드만 가져온다. 이 검색 방법은 1번 단계에서 알아낸 '10001' 값과 쿼리의 WHERE 절에 사용된 "from_Date='1985-03-01'" 조건을 합쳐서 "emp_no=10001 AND from_date='1985-03-01'" 조건으로 (emp_no, from_date) 인덱스를 검색하는 것과 거의 흡사하다.
> 3. (emp_no, from_date) 인덱스에서 emp_no의 그 다음 유니크한(그룹 키) 값을 가져온다.
> 4. 3번 단계에서 결과가 더 없으면 처리를 종료하고, 결과가 있다면 2번 과정으로 돌아가 반복 수행한다.

- MySQL의 루스 인덱스 스캔 방식은 단일 테이블에 대해 수행되는 GROUP BY 처리에만 사용할 수 있다.
- 인덱스 레인지 스캔에서는 유니크한 값의 수가 많을수록 성능이 향상되지만, 루스 인덱스 스캔에서는 유니크한 값의 수가 적을수록 성능이 향상된다.
- 루스 인덱스 스캔이 사용될 수 있을지 없을지 판단하는 것은 WHERE 절의 조건이나 ORDER BY 절이 인덱스를 사용할 수 있을지 없을지 판단하는 것보다 더 어렵다.
- 다음 쿼리들은 루스 인덱스 스캔을 사용할 수 있는 쿼리다. 판별하는 연습을 해보자.
- 인덱스는 (col1, col2, col3) 으로 생성되어 있다.
```mysql
SELECT col1, col2 FROM tb_test GROUP BY col1, col2;
SELECT DISTINCT col1, col2 FORM tb_test;
SELECT col1, MIN(col2) FROM tb_test GROUP BY col1;
SELECT col1, col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;
SELECT MAX(col3), MIN(col3), col1, col2 FROM tb_test WHERE col2 > const GROUP BY col1, col2;
SELECT col2 FROM tb_test WHERE col1 < const GROUP BY col1, col2;
SELECT col1, col2 FROM tb_test WHERE col3 = const GROUP BY col1, col2;
```

- 다음 쿼리는 루스 인덱스 스캔을 사용할 수 없는 쿼리다.
```mysql
-- // MIN() MAX() 이외의 집합 함수가 사용됐기 때문에 루스 인덱스 스캔 사용 불가
SELECT col1, SUM(col2) FROM tb_test GROUP BY col1;

-- // GROUP BY에 사용된 칼럼이 인덱스 구성 칼럼의 순서와 다르기 때문에 사용 불가
SELECT col1, col2 FROM tb_test GROUP BY col2, col3;

-- // SELECT 절의 칼럼이 GROUP BY와 일치하지 않기 때문에 사용 불가
SELECT col1, col3 FROM tb_test GROUP BY col1, col2;
```

- MySQL 8.0 부터는 루스 인덱스 스캔과 동일한 방식으로 작동하는 인덱스 스킵 스캔 최적화도 도입됐다.
- 이전 버전까지는 GROUP BY 절의 처리를 위해서만 루스 인덱스 스캔이 사용됐지만, 
- 인덱스 스킵 스캔이 도입되면서 옵티마이저가 쿼리에서 필요로 하는 레코드를 검색하는 부분까지 최적화가 가능해졌다. 
- 인덱스 스킵 스캔도 조건이 누락된 인덱스의 선행 칼럼이 유니크한 값을 많이 가질수록 쿼리 성능이 떨어진다.

#### 임시 테이블을 이용한 GROUP BY
- GROUP BY 기준 칼럼이 인덱스를 전혀 사용하지 못할 때는 이 방식으로 처리된다.
- 쿼리 실행 계획에서 Extra 칼럼에 "Using filesort" 없이 "Using temporary"만 표시되는데,
- MySQL 8.0 이전 버전에서는 그루핑 칼럼을 기준으로 묵시적인 정렬까지 함께 수행했으나, 이후 버전부터는 정렬은 실행되지 않게 바뀌었다.
- MySQL 8.0 에서는 GROUP BY 가 필요한 경우 내부적으로 GROUP BY 절의 칼럼들로 구성된 유니크 인덱스를 가진 임시 테이블을 만들어서 중복 제거와 집합 함수 연산을 수행한다.

### DISTINCT 처리
- 특정 칼럼의 유니크한 값만 조회하려면 SELECT 쿼리에 DISTINCT를 사용한다.
- DISTINCT는 MIN(), MAX(), COUNT() 등의 집합 함수와 함께 사용하는 경우와 단독으로 사용하는 경우가 있다.
- 집합 함수와 같이 DISTINCT가 사용되는 쿼리의 실행 계획에서 인덱스를 사용하지 못할 때는 항상 임시 테이블이 필요하다.
- 하지만 실행 계획의 Extra 칼럼에는 "Using temporary" 메시지가 출력되지 않는다.

#### SELECT DISTINCT
- 단순 SELECT DISTINCT 쿼리는 GROUP BY 쿼리와 동일하게 처리된다.
- DISTINCT를 사용할 때 자주 실수하는 부분은 DISTINCT는 레코드를 유니크하게 SELECT 하는 것이지 특정 칼럼만 유니크하게 조회하는 것이 아니다.
- 즉, SELECT DISTINCT col1, col2 FROM tb_test; 는 col1, col2의 조합이 유니크한 레코드를 조회하는 것이다.
```mysql
SELECT DISTINCT(col1), col2 FROM tb_test;
```
- 위와 같이 함수처럼 사용하면 col1의 값이 유니크한 레코드를 조회하는 것이 아니라, col1과 col2의 조합된 값이 유니크한 레코드를 조회한다.

#### 집합 함수와 함께 사용된 DISTINCT
- 집합 함수 내에서 DISTINCT를 사용하면 일반적인 SELECT DISTINCT와는 다르게 동작한다.
- 집합 함수 내에서는 칼럼값이 유니크한 것들을 가져온다.

```mysql
EXPLAIN SELECT COUNT(DISTINCT s.salary)
FROM employees e, salaries s 
WHERE e.emp_no = s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```
- 위 쿼리는 내부적으로는 "COUNT(DISTINCT s.salary)"를 처리하기 위해 임시 테이블을 사용한다.
- 하지만 실행 계획에는 임시테이블을 사용한다는 메시지가 표시되지 않는다.
```mysql
+----+-------+-------+---------+-------------------------------+
| id | table | type  | key     | rows Extra                    |
+----+-------+-------+---------+-------------------------------+
|  1 | e     | range | PRIMARY |  100 Using where; Using index |
|  1 | s     | ref   | PRIMARY |   10 NULL                     |                                                  
+----+-------+-------+---------+-------------------------------+
```
- employees 테이블과 salaries 테이블을 조인한 결과에서 salary 칼럼의 값만 저장하기 위한 임시 테이블을 만들어서 사용한다.
- 이때 임시 테이블의 salary 칼럼에는 유니크 인덱스가 생성되기 때문에 레코드 건수가 많아지면 상당히 느려질 수 있는 형태다.
- 위의 쿼리에 COUNT(DISTINCT ...)를 추가해서 다음과 같이 변경해보자.
```mysql
EXPLAIN SELECT COUNT(DISTINCT s.salary), 
               COUNT(DISTINCT e.last_name)
FROM employees e, salaries s 
WHERE e.emp_no = s.emp_no
AND e.emp_no BETWEEN 100001 AND 100100;
```
- 위 쿼리는 s.salary 칼럼과 e.last_name 칼럼의 값을 저장하는 2개의 임시 테이블을 사용한다.
- 하지만 인덱스된 칼럼에 대해 DISTINCT 처리를 수행할 때는 인덱스를 풀 스캔하거나 레인지 스캔하면서 임시 테이블 없이 최적화된 처리를 수행할 수 있다.

### 내부 임시 테이블 활용
- MySQL 엔진이 스토리지 엔진으로부터 받아온 레코드를 정렬하거나 그루핑할 때는 내부적인 임시 테이블을 사용한다.
- 일반적인 임시 테이블은 처음에는 메모리에 생성됐다가 테이블의 크기가 커지면 디스크로 옮겨진다.
- 내부적인 가공을 위해 생성하는 임시 테이블은 다른 세션이나 다른 쿼리에서는 볼 수 없으며 사용하라 수 없다.
- 그리고 쿼리의 처리가 완료되면 자동으로 삭제된다.

#### 메모리 임시 테이블과 디스크 임시 테이블
- MySQL 8.0 이전에는 원본 테이블의 스토리지 엔진과 관계없이 임시 테이블이 메모리를 사용할 때는 MEMORY 스토리지 엔진, 디스크는 MyISAM 스토리지 엔진을 사용한다.
- MySQL 8.0 부터는 메모리 임시 테이블은 TempTable 스토리지 엔진을 사용하고, 디스크 임시 테이블은 InnoDB 스토리지 엔진을 사용한다.
   

- 기존 MEMORY 스토리지 엔진은 VARBINARY, VARCHAR 같은 가변 길이 타입을 지원하지 못해서 최대 길이만큼 메모리를 할당해서 사용했고, 이는 메모리 낭비 문제가 있었다.
- 그리고 디스크 임시 테이블인 MyISAM 스토리지 엔진은 트랜잭션을 지원하지 못한다는 문제가 있었다.
- 그래서 8.0 버전부터 개선되었다.

#### 임시 테이블이 필요한 쿼리
- 아래 패턴의 쿼리가 대표적으로 내부 임시 테이블을 생성하는 케이스다.
> - ORDER BY와 GROUP BY에 명시된 칼럼이 다른 쿼리
> - ORDER BY나 GROUP BY에 명시된 칼림이 조인의 순서상 첫 번째 테이블이 아닌 쿼리
> - DISTINCT와 ORDER BY가 동시에 쿼리에 존재하는 경우 또는 DISTINCT가 인덱스로 처리되지 못하는 쿼리
> - UNION이나 UNION DISTINCT가 사용된 쿼리(select_type 칼럼이 UNION RESULT인 경우)
> - 쿼리의 실행 계획에서 select_type이 DERIVED인 쿼리

- 쿼리 실행 계획에서 Extra 칼럼에 "Using temporary"가 표시되면 내부적으로 임시 테이블을 사용한다는 의미다.
- 하지만 위에서 아래 3가지 패턴은 "Using temporary"가 표시되지 않지만 내부적으로 임시 테이블을 사용한다.
- 1~4번 패턴은 유니크 인덱스를 가지는 내부 임시 테이블이 생성되고, 5번 패턴은 유니크 인덱스 없는 내부 임시 테이블이 생성된다.
- 일반적으로 유니크 인덱스가 있는 내부 임시 테이블은 성능이 상당히 느리다.

#### 임시 테이블이 디스크에 생성되는 경우
- 다음과 같은 조건에서는 메모리 임시 테이블을 사용할 수 없다.
> - UNION이나 UNION ALL에서 SELECT되는 칼럼 중에서 길이가 512바이트 이상인 크기의 칼럼이 있는 경우
> - GROUP BY나 DISTINCT 칼럼에서 512바이트 이상인 크기의 칼럼이 있는 경우
> - 메모리 임시 테이블의 크기가 설정한 시스템 변수보다 큰 경우

#### 임시 테이블 관련 상태 변수
- MySQL 서버의 상태 변수(SHOW SESSION STATUS LIKE 'Created_tmp%')를 통해 임시 테이블 생성 횟수를 확인할 수 있다.
> - Created_tmp_tables : 임시 테이블 생성 횟수 (메모리 + 디스크)
> - Created_tmp_disk_tables : 디스크 임시 테이블 생성 횟수

## 9.3 고급 최적화
- 옵티마이저가 실행 계획을 수립할 때 통계 정보와 옵티마이저 옵션을 고려해 최적의 실행 계획을 수립한다.
- 옵티마이저 옵션은 크게 조인 관련 옵션과 옵티마이저 스위치로 구분할 수 있다.

### 옵티마이저 스위치 옵션
- 옵티마이저 스위치 옵션은 optimizer_switch 시스템 변수로 설정할 수 있다.

#### MRR과 배치 키 액세스(mrr & batch_key_access)
- MRR(Multi-Range Read)은 InnoDB 스토리지 엔진의 쿼리 처리 방식 중 하나로, 여러 개의 레인지를 한 번에 읽어오는 방식이다.
- 드라이빙 테이블의 레코드를 읽어서 조인을 즉시 실행하지 않고 버퍼링해서 한 번에 읽어오는 방식이다.

#### 블록 네스티드 루프 조인(block_nested_loop)
- MySQL 서버에서 사용되는 대부분의 조인은 `네스티드 루프 조인(Nested Loop Join)` 방식이다.
- 연결 조건이 되는 칼럼에 모두 인덱스가 있는 경우 사용되는 조인 방식이다.
- 레코드를 읽어서 다른 버퍼 공간에 저장하지 않고 즉시 드리븐 테이블의 레코드를 찾아서 반환한다.
   

- `블록 네스티드 루프 조인`은 조인 버퍼가 사용되고, 테이블 조인 순서가 반대이다.
- 조인 쿼리의 실행 계획에서 Extra 칼럼에 "Using Join Buffer"가 표시되면 조인 버퍼를 사용한다는 의미이다.
- 조인은 드라이빙 테이블에서 일치하는 레코드의 건수만큼 드리븐 테이블을 검색하면서 처리된다.
- 드라이빙 테이블은 한 번에 쭉 읽지만, 드리븐 테이블은 여러 번 읽는다. 그래서 최대한 드리븐 테이블 검색이 인덱스를 사용할 수 있게 실행 계획을 수립한다.
- 하지만 드리븐 테이블의 풀 테이블 스캔이나 인덱스 풀 스캔을 해야한다면 옵티마이저는 드라이빙 테이블에서 읽은 레코드를 메모리에 캐시한 후 캐시로 조인하는 형태로 처리한다.
- 이때 사용하는 메모리를 조인 버퍼라고 한다.

#### 인덱스 컨디션 푸시다운(index_condition_pushdown)
- 인덱스가 (col1, col2) 같은 구조로 되어있는 경우에
- `WHERE col1 = 'A' AND col2 LIKE '%B'` 같은 조건이 있으면 col1은 인덱스를 사용할 수 있지만 col2는 인덱스를 사용할 수 없다.
- 인덱스 컨디션 푸시다운기능을 사용하지 않으면 col1을 먼저 인덱스로 검색한 후, col2의 조건은 테이블 레코드에서 검색한다.
- 하지만 인덱스에 이미 col2값이 저장되어 있기 때문에 테이블 레코드에 가서 검색하는 과정은 불필요한 I/O를 발생시킨다.
- 인덱스 컨디션 푸시다운을 사용하면 인덱스 안에서 모든 조건 검색을 처리하고 필요한 레코드만 조회할 수 있다.

#### 인덱스 확장
- use_index_extensions 옵션은 InnoDB 엔진을 사용하는 테이블에서 세컨더리 인덱스에 추가된 프라이머리 키를 활용할 수 있게 해준다.
- 세컨더리 인덱스가 col3 이고 프라이머리 키가 (col1, col2) 라면,
- 사실상 세컨더리 인덱스는 (col3, col1, col2) 인 인덱스처럼 사용할 수 있다.

#### 인덱스 머지(index_merge)
- WHERE 조건이 여러 개 있더라도 하나의 인덱스에 포함된 칼럼에 대한 조건만 인덱스로 검색하고, 나머지 조건은 읽어온 레코드에서 체크하는 형태가 일반적이다.
- 하나의 인덱스 만으로 작업 범위를 충분히 줄일 수 있다면 테이블별로 하나의 인덱스만 활용하는 것이 효율적이다.
- 하지만 각각의 조건이 서로 다른 인덱스를 사용할 수 있고 그 조건을 만족하는 레코드가 많을 것으로 예상되면 인덱스 머지 실행 계획을 선택한다.
   

- 인덱스 머지 실행 계획은 3개의 세부 실행 계획으로 나눌 수 있다.
> 1. index_merge_intersection
> 2. index_merge_sort_union
> 3. index_merge_union

#### 1. 인덱스 머지 - 교집합(index_merge_intersection)
- 조건 A도 인덱스 사용이 가능하고 조건 B도 인덱스 사용이 가능한 상태에서 2개의 인덱스를 모두 사용하는 실행 계획을 사용하는 방법이다.
- 조건 A를 만족하는 레코드 253개, 조건 B를 만족하는 레코드 10000개, 둘 다 만족하는 레코드가 14개라면 교집합만 가져오는 방식이 훨씬 효율적이다.
- 만약 하나의 조건만으로 충분히 효율적으로 쿼리를 처리할 수 있다만 옵티마이저는 하나만 사용하는 실행 계획을 사용할 것이다.

#### 2. 인덱스 머지 - 합집합(index_merge_union)
- 2개 이상의 조건이 각각 인덱스를 사용하되 OR 연산자로 연결된 경우에 사용된다.
- 각 조건별로 가져온 인덱스 검색 결과를 인덱스에 포함된 프라이머리 키를 활용해 중복을 제거하고 합집합을 만들어서 반환한다.

#### 3. 인덱스 머지 - 정렬 후 합집합(index_merge_sort_union)
- 인덱스 머지 작업을 하는 도중에 정렬이 필요한 경우에 사용된다.
- 합집합 과정을 거치려면 인덱스의 정렬 순서가 일치해야 하기 때문에, 조건별로 가져온 인덱스 검색 결과의 정렬 순서가 서로 다를때 사용된다.

#### 세미 조인(semijoin)
- 다른 테이블과 실제 조인을 수행하지는 않고, 다른 테이블에서 조건에 일치하는 레코드가 있는지만 체크하는 형태의 쿼리를 세미조인이라고 한다.
```mysql
SELECT *
FROM employees e 
WHERE e.emp_no IN 
    (SELECT de.emp_no FROM dept_emp de WHERE de.from_date='1995-01-01');
```
- 세미 조인 최적화 기능이 없었을때는 employees 테이블을 풀 스캔하면서 한 건 한 건 서브쿼리의 조건에 일치하는지 비교했었다. (매우 비효율)
   

- 최근 도입된 세미 조인 최적화에 대해 알아보자
> - Table Pull-out
> - Duplicate Weed-out
> - First Match
> - Loose Scan
> - Materialization

#### 테이블 풀-아웃(Table pull-out)
- 세미 조인의 서브쿼리에 사용된 테이블을 아우터로 쿼리로 끄집어낸 후에 쿼리를 조인 쿼리로 재작성하는 최적화다.
```mysql
EXPLAIN
SELECT * FROM employees e
WHERE e.emp_no IN (SELECT de.emp_noo FROM dept_emp de WHERE de.dept_no='d009');
```

```mysql
+----+--------------+-------+---------+----------+-------+--------------+
| id | select_type  | table | type    | key      | rows  | Extra        |
+----+--------------+-------+---------+----------+-------+--------------+
|  1 | SIMPLE       | de    | ref     | PRIMARY  | 46012 | Using index  |
|  1 | SIMPLE       | e     | eq_ref  | PRIMARY  |     1 | NULL         |
+----+--------------+-------+---------+----------+-------+--------------+
```
- 테이블 풀-아웃 최적화는 별도로 실행계획에 표시되지 않는다.
- 정확하게 확인하는 방법은 EXPLAIN 명령을 실행한 직후 SHOW WARNINGS 명령으로 옵티마이저가 재작성한 쿼리를 확인하는 것이다.

```mysql
SHOW WARINGS \G
*************************** 1. row ***************************
  Level: Note
   Code: 1003
Message: /* select#1 */ select `employees`.`emp_no` AS `emp_no`,
                employees.e.birth_date AS birth_date,
                employees.e.first_name AS first_name,
                employees.e.last_name AS last_name,
                employees.e.gender AS gender,
                employees.e.hire_date AS hire_date
         from employees.dept_emp de 
           JOIN employees.employees e
         WHERE ((employees.e.emp_no = employees.de.emp_no) 
                AND (employees.de.dept_no = 'd009'))
```
- 확인해보면 IN 형태가 사라지고 JOIN으로 쿼리가 재작성되었다.
- 테이블 풀-아웃 최적화의 몇 가지 제한 사항과 특성이다.
> - 세미 조인 서브쿼리에서만 사용 가능하다.
> - 서브쿼리 부분이 UNIQUE 인덱스나 프라이머리 키 룩업으로 결과가 1건인 경우에만 사용 가능하다.
> - 적용하더라도 기존 쿼리에서 가능했던 최적화 방법이 사용 불가능한 것이 아니므로 MySQL에서는 가능하다면 최대한 사용한다.
> - 서브쿼리의 테이블을 아우터 쿼리로 가져와서 조인으로 풀어쓰는 최적화를 수행하는데, 만약 서브쿼리의 모든 테이블이 아우터 쿼리로 끄집어 낼 수 있다면 서브쿼리 자체는 없어진다.
> - MySQL에는 '최대한 서브쿼리를 조인으로 풀어서 사용해라'라는 튜닝 가이드가 많은데, 이 가이드를 그대로 실행하는 것이다.

#### 퍼스트 매치(firstmatch)
- IN 형태의 세미 조인을 EXISTS 형태로 튜닝한 것과 비슷한 방법으로 실행된다.

```mysql
EXPLAIN SELECT *
FROM employees e WHERE e.first_name='Matt'
  AND e.emp_no IN (
      SELECT t.emp_no FROM titles t 
      WHERE t.from_date BETWEEN '1995-05-01' AMD '1995-01-30'
      );
```

```mysql
+----+-------+------+--------------+------+-----------------------------------------+
| id | table | type | key          | rows | Extra                                   |
+----+-------+------+--------------+------+-----------------------------------------+
|  1 | e     | ref  | ix_firstname |  233 | NULL                                    |
|  1 | t     | ref  | PRIMARY      |    1 | Using where; Using index; FirstMatch(e) |
+----+-------+------+--------------+------+-----------------------------------------+
```
- 실행 계획의 id 칼럼이 모두 1로 표시된 것으로 봐서 조인으로 처리됐다는 것을 알 수 있다.
- FirstMatch(e) 문구는 일치하는 레코드 1건만 찾으면 더이상의 titles 테이블 검색을 하지 않는다는 것을 의미한다. (EXISTS와 동일)

> - 서브쿼리에서 하나의 레코드만 검색되면 더 이상의 검색을 멈추는 단축 실행 경로이기 때문에, 서브쿼리는 그 서브쿼리가 참조하는 모든 아우터 테이블이 먼저 조회된 이후에 실행된다.
> - 실행 계획의 Extra 칼럼에는 FirstMatch(table) 문구가 표시된다.
> - 상관 서브쿼리(Correlated subquery)에서도 사용 가능하다.
> - GROUP BY 나 집합 함수가 사용된 서브쿼리의 최적화에는 사용될 수 없다.

#### 루스 스캔(loosescan)
- 인덱스를 사용하는 GROUP BY 최적화의 루스 인덱스 스캔과 비슷한 읽기 방식을 사용한다.

```mysql
EXPLAIN
SELECT * FROM departments d WHERE d.dept_no IN (
    SELECT de.dept_no FROM dept_emp de );
```
- departments 테이블의 레코드는 9건이지만 dept_emp 테이블은 약 33만건이다.
- 그런데 dept_emp 테이블에는 (dept_no + emp_no) 칼럼의 조합으로 프라이머리 키 인덱스가 있다.
- 이 프라이머리 키는 전체 레코드 수는 33만건 정도지만 dept_no 만으로 그루핑해서 보면 결국 9건이다.
- dept_emp 테이블의 프라이머리 키를 루스 인덱스 스캔으로 유니크한 dept_no만 읽으면 아주 효율적으로 서브쿼리 부분을 실행할 수 있다.

```mysql
+----+-------+--------+---------+--------+------------------------+
| id | table | type   | key     | rows   | Extra                  |
+----+-------+--------+---------+--------+------------------------+
|  1 | de    | index  | PRIMARY | 331143 | Using index; LooseScan |
|  1 | d     | eq_ref | PRIMARY |      1 | NULL                   |
+----+-------+--------+---------+--------+------------------------+
```
- 서브쿼리에 사용된 dept_emp 테이블이 드라이빙 테이블로 실행되며, dept_emp 테이블의 프라이머리 키를 dept_no 부분에서 유니크하게 한 건씩만 읽고 있다는 것을 보여준다.
- 실행계획의 각 테이블에 할당된 id 값이 동일하게 1인것은 MySQL 내부적으로는 조인처럼 처리됐다는 것을 말해준다.

> - 루스 인덱스 스캔으로 서브쿼리 테이블을 읽고, 그다음으로 아우터 테이블을 드리븐으로 사용해서 조인을 수행한다.
> - 서브 쿼리 부분이 루스 인덱스 스캔을 사용할 수 있는 조건이 갖춰져야 사용할 수 있는 최적화다.
> - 다음과 같은 형태의 서브쿼리들에서 사용할 수 있다.   
> `SELECT .. FROM .. WHERE expr IN (SELECT keypart1 FROM tab WHERE ...)`   
> `SELECT .. FROM .. WHERE expr IN (SELECT keypart2 FROM tab WHERE keypart1='상수' ...)`


#### 구체화(Materialization)
- 세미 조인에 사용된 서브쿼리를 통째로 구체화해서 쿼리를 최적화한다는 의미
- 구체화는 쉽게 표현하면 내부 임시 테이블을 생성한다는 것을 의미 

```mysql
EXPLAIN
SELECT * 
FROM employees e 
WHERE e.emp_no IN 
      (SELECT de.emp_no FROM dept_emp de 
       WHERE de.from_date='1995-01-01');
```
- 이 쿼리는 FirstMatch 최적화를 사용하면 employees 테이블에 대한 조건이 서브쿼리 이외에는 아무것도 없기 때문에 employees 테이블을 풀 스캔해야 한다.
- 이러한 형태의 쿼리를 위해 서브쿼리 구체화가 도입됐다.

```mysql
+----+--------------+-------------+---------+-------------+--------------------+
| id | select_type  | table       | type    | key         | ref                |
+----+--------------+-------------+---------+-------------+--------------------+
|  1 | SIMPLE       | <subquery2> | ALL     | NULL        | NULL               |
|  1 | SIMPLE       | e           | eq_ref  | PRIMARY     | <subquery2>.emp_no |
|  2 | MATERIALIZED | de          | ref     | ix_fromdate | const              |
+----+--------------+-------------+---------+-------------+--------------------+
```
- 실행 계획에서 MATERIALIZED라고 표시되는 것이 구체화를 사용했다는 의미다.
- dept_emp 테이블을 읽는 서브쿼리가 먼저 실행되어 임시테이블이 만들어졌다.
- 서브쿼리가 구체화된 임시테이블과 employees 테이블을 조인해서 결과를 반환한다.
- 구체화 최적화는 다른 서브쿼리 최적화와 달리 서브쿼리 내에 GROUP BY 절이 있어도 사용할 수 있다.

> - IN(subquery)에서 서브쿼리는 상관 서브쿼리(Correlated subquery)가 아니어야 한다.
> - 서브쿼리는 GROUP BY나 집합 함수들이 사용돼도 구체화를 사용할 수 있다.
> - 구체화가 사용된 경우에는 내부 임시테이블이 사용된다.

#### 중복 제거(Duplicate Weed-out)
- 세미 조인 서브쿼리를 일반적인 INNER JOIN 쿼리로 바꿔서 실행하고 마지막에 중복된 레코드를 제거하는 방법으로 처리한다.

```mysql
EXPLAIN
SELECT * FROM employees e
WHERE e.emp_no IN (SELECT s.emp_no FROM salaries s WHERE s.salary > 150000);
```

- salaries 테이블의 프라이머리 키가 (emp_no + from_date) 이므로 salary가 150000 이상인 레코드를 조회하면 그 결과에는 중복된 emp_no가 발생할 수 있다.
- 그래서 다음과 같이 재작성해서 GROUP BY 절을 넣어주면 세미 조인 서브쿼리와 동일한 결과를 얻을 수 있다.

```mysql
SELECT e.* 
FROM employees e, salaries s
WHERE e.emp_no=s.emp_no AND s.salary>150000
GROUP BY e.emp_no;
```

- 실제로 중복 제거 최적화 알고리즘은 원본 쿼리를 위와 같이 INNER JOIN + GROUP BY 절로 바꿔서 실행하는 것과 동일한 작업으로 쿼리를 실행한다.

```mysql
+----+--------------+-------+---------+-----------+-------------------------------------------+
| id | select_type  | table | type    | key       | Extra                                     |
+----+--------------+-------+---------+-----------+-------------------------------------------+
|  1 | SIMPLE       | s     | range   | ix_salary | Using where; Using index; Start temporary |
|  1 | SIMPLE       | e     | eq_ref  | PRIMARY   | End temporary                             |
+----+--------------+-------+---------+-----------+-------------------------------------------+
```

- 실행 계획에서 별도로 Duplicate Weedout이라고 표시되지 않는다.
- 하지만 조인을 수행하는 작업과 임시 테이블로 저장하는 작업은 반복적으로 실행되는 과정이다.
- 반복과정이 시작되는 테이블의 실행 계획에는 Start temporary, 반복과정이 끝나는 테이블의 실행 계획에는 End temporary가 표시된다.

#### 컨디션 팬아웃(condition_fanout_filter)

#### 파생 테이블 머지(derived_merge)

#### 인비저블 인덱스(use_invisible_index)

#### 스킵 스캔(skip_scan)

#### 해시 조인(hash_join)

#### 인덱스 정렬 선호(prefer_ordering_index)

### 조인 최적화 알고리즘
- MySQL에는 조인 쿼리 실행 계획 최적화를 위한 알고리즘이 2개 있다.
- 조인 최적화는 나름 많이 개선됐다고 하지만, 테이블의 개수가 많아지면 실행 계획 수립이 복잡해지고, 최적화가 어려워진다.
#### Exhaustive 검색 알고리즘
- MySQL 5.0 이전 버전에서 사용되던 조인 최적화 기법으로, FROM 절에 명시된 모든 테이블의 조합에 대해 실행 계획의 비용을 계산해서 최적의 조합 1개를 찾는 방법이다.
- 테이블이 20개라면 가능한 조인 조합은 모두 20! 이므로 3628800개가 된다.
- 테이블이 10개만 넘어도 실행 계획을 수립하는데 몇 분이 걸리고, 11개가 되면 11배의 시간이 더 걸린다.

#### Greedy 검색 알고리즘
- 시간 소모적인 문제점을 해결하기 위해 MySQL 5.0 부터 도입된 최적화 기법이다.
> 1. 전체 N개의 테이블 중에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
> 2. 1번에서 생성된 조인 조합 중에서 최소 비용의 실행 계획 하나를 선정
> 3. 2번에서 선정된 실행 계획의 첫 번째 테이블을 '부분 실행 계획'의 첫 번째 테이블로 선정
> 4. 전체 N-1개의 테이블 중(3번 테이블 제외)에서 optimizer_search_depth 시스템 설정 변수에 정의된 개수의 테이블로 가능한 조인 조합을 생성
> 5. 4번에서 생성된 조인 조합들을 하나씩 3번에서 생성된 '부분 실행 계획'에 대입해 실행 비용을 계산
> 6. 5번의 계산 결과, 최적의 실행 계획에서 두 번째 테이블을 3번에서 생성된 '부분 실행 계획'의 두 번째 테이블로 선정
> 7. 남은 테이블이 모두 없어질 때까지 4~6번의 과정 반복하면서 '부분 실행 계획'에 테이블의 조인 순서를 기록
> 8. 최종적으로 '부분 실행 계획'이 테이블의 조인 순서로 결정됨

- Greedy 검색 알고리즘은 optimizer_search_depth 시스템 설정 변수에 따라 조인 최적화 비용이 상당히 줄어들 수 있다. (기본값 62)
- MySQL 8.0 버전의 조인 최적화는 많이 개선되어 optimizer_search_depth 설정값에 크게 영향받지 않는 것으로 보인다.


## 9.4 쿼리 힌트

- MySQL 서버에서 사용 가능한 쿼리 힌트는 2가지다
> - 인덱스 힌트
> - 옵티마이저 힌트

- 인덱스 힌트는 예전 버전부터 사용되어 오던 USE INDEX 같은 힌트를 의미하며,
- 옵티마이저 힌트는 MySQL 5.6 버전부터 새롭게 추가되기 시작한 힌트들을 말한다.

### 인덱스 힌트
- STARIGHT_JOIN, USE INDEX 등을 포함한 인덱스 힌트들은 모두 옵티마이저 힌트가 도입되기 전에 사용되던 ㅓ기능들이다.
- 이들은 모두 SQL 문법에 맞게 사용해야 하기 때문에 ANSI-SQL 표준 문법을 준수하지 못하게 되는 단점이 있다.
- 옵티마이저 힌트들은 모두 MySQL 서버를 제외한 다른 RDBMS에서는 주석으로 해석하기 때문에 ANSI-SQL 표준을 준수한다고 볼 수 있다.
- 그래서 가능하다면 인덱스 힌트보다는 옵티마이저 힌트를 사용할 것을 추천한다.

#### STRAIGHT_JOIN
- STRAIGHT_JOIN은 SELECT, UPDATE, DELETE 쿼리에서 여러 개의 테이블이 조인되는 경우 조인 순서를 고정하는 역할을 한다.

```mysql
SELECT STRAIGHT_JOIN
      e.first_name, e.last_name, d.dept_name
    FROM employees e, dept_emp de, departments d
    WHERE e.emp_no=de.emp_no 
      AND de.dept_no=d.dept_no;

SELECT /*! STRAIGHT_JOIN */
    e.first_name, e.last_name, d.dept_name
FROM employees e, dept_emp de, departments d
WHERE e.emp_no=de.emp_no
  AND de.dept_no=d.dept_no;
```
- STRAIGHT_JOIN 힌트는 FROM 절에 명시된 테이블의 순서대로 조인을 수행하도록 유도한다.
- 주로 다음 기준에 맞게 조인 순서가 결정되지 않는 경우에만 사용하는 것이 좋다.
> - 임시 테이블과 일반 테이블의 조인: 이 경우에는 거의 일반적으로 임시 테이블을 드라이빙 테이블로 선정하는 것이 좋다. 옵티마이저가 실행 계획을 제대로 수립하지 못하는 경우에만 사용하면 된다.
> - 임시 테이블끼리 조인: 임시 테이블은 항상 인덱스가 없기 때문에 어느 테이블을 먼저 드라이빙으로 읽어도 무관하므로 크기가 작은 테이블을 드라이빙으로 선택해주는 것이 좋다.
> - 일반 테이블끼리 조인: 양쪽 테이블 모두 조인 칼럼에 인덱스가 있거나 모두 없는 경우에는 레코드 건수가 적은 테이블을 드라이빙으로 선택해주는 것이 좋으며, 그 이외에는 조인 칼럼에 인덱스가 없는 테이블을 드라이빙으로 선택하는 것이 좋다.

- 여기서 레코드 건수는 테이블 전체 레코드 건수가 이닌 WHERE 조건을 만족하는 레코드 건수다

#### USE INDEX / FORCE INDEX / IGNORE INDEX
- 보통 옵티마이저는 어떤 인덱스를 사용할지 잘 선택하는 편이지만, 3~4개 이상의 칼럼을 포함하는 비슷한 인덱스가 여러 개 존재하면 가끔 실수를 하는데, 이런 경우에 특정 인덱스를 사용하도록 힌트를 추가한다.
- 인덱스 힌트는 크게 3종류가 있다.
> - USE INDEX: 가장 자주 사용되는 인덱스 힌트로, 특정 테이블의 인덱스를 사용하도록 권장하는 힌트 정도다. 항상 그 인덱스를 사용하는건 아니다.
> - FORCE INDEX: USE INDEX보다 영향력이 더 센 힌트다. 하지만 USE INDEX 힌트의 영향력도 충분히 세서 USE INDEX 힌트로도 사용하지 않는 경우라면 FORCE INDEX 힌트로도 사용하지 않는 경우가 많았다.
> - IGNORE INDEX: 특정 인덱스를 사용하지 못하게 하는 용도로 사용한다. 풀 테이블 스캔을 사용하도록 유도하기 위해 사용할 수도 있다.

- 3가지 모두 용도를 명시해 줄 수 있다.
> - USE INDEX FOR JOIN: 테이블 간의 조인과 레코드 검색까지 포함한 용도
> - USE INDEX FOR ORDER BY: ORDER BY 절에만 해당 인덱스를 사용하도록 제한 
> - USE INDEX FOR GROUP BY: GROUP BY 절에만 해당 인덱스를 사용하도록 제한

